{"ast":null,"code":"import _classCallCheck from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { toUint8Array, uint8ArrayToBigInt } from '../common/utils.js';\nimport { FeeMarketEIP1559Transaction } from './eip1559Transaction.js';\nimport { AccessListEIP2930Transaction } from './eip2930Transaction.js';\nimport { Transaction } from './legacyTransaction.js';\nvar extraTxTypes = new Map();\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport var TransactionFactory = /*#__PURE__*/function () {\n  // It is not possible to instantiate a TransactionFactory object.\n  // eslint-disable-next-line @typescript-eslint/no-empty-function, no-useless-constructor\n  function TransactionFactory() {\n    _classCallCheck(this, TransactionFactory);\n  }\n  _createClass(TransactionFactory, null, [{\n    key: \"typeToInt\",\n    value: function typeToInt(txType) {\n      return Number(uint8ArrayToBigInt(toUint8Array(txType)));\n    }\n  }, {\n    key: \"registerTransactionType\",\n    value: function registerTransactionType(type, txClass) {\n      var txType = TransactionFactory.typeToInt(type);\n      extraTxTypes.set(txType, txClass);\n    }\n    /**\n     * Create a transaction from a `txData` object\n     *\n     * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)\n     * @param txOptions - Options to pass on to the constructor of the transaction\n     */\n  }, {\n    key: \"fromTxData\",\n    value: function fromTxData(txData) {\n      var txOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (!('type' in txData) || txData.type === undefined) {\n        // Assume legacy transaction\n        return Transaction.fromTxData(txData, txOptions);\n      }\n      var txType = TransactionFactory.typeToInt(txData.type);\n      if (txType === 0) {\n        return Transaction.fromTxData(txData, txOptions);\n      }\n      if (txType === 1) {\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        return AccessListEIP2930Transaction.fromTxData(\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        txData, txOptions);\n      }\n      if (txType === 2) {\n        return FeeMarketEIP1559Transaction.fromTxData(\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        txData, txOptions);\n      }\n      var ExtraTransaction = extraTxTypes.get(txType);\n      if (ExtraTransaction === null || ExtraTransaction === void 0 ? void 0 : ExtraTransaction.fromTxData) {\n        return ExtraTransaction.fromTxData(txData, txOptions);\n      }\n      throw new Error(\"Tx instantiation with type \".concat(txType, \" not supported\"));\n    }\n    /**\n     * This method tries to decode serialized data.\n     *\n     * @param data - The data Uint8Array\n     * @param txOptions - The transaction options\n     */\n  }, {\n    key: \"fromSerializedData\",\n    value: function fromSerializedData(data) {\n      var txOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (data[0] <= 0x7f) {\n        // Determine the type.\n        switch (data[0]) {\n          case 1:\n            return AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);\n          case 2:\n            return FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);\n          default:\n            {\n              var ExtraTransaction = extraTxTypes.get(Number(data[0]));\n              if (ExtraTransaction === null || ExtraTransaction === void 0 ? void 0 : ExtraTransaction.fromSerializedTx) {\n                return ExtraTransaction.fromSerializedTx(data, txOptions);\n              }\n              throw new Error(\"TypedTransaction with ID \".concat(data[0], \" unknown\"));\n            }\n        }\n      } else {\n        return Transaction.fromSerializedTx(data, txOptions);\n      }\n    }\n    /**\n     * When decoding a BlockBody, in the transactions field, a field is either:\n     * A Uint8Array (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))\n     * A Uint8Array[] (Legacy Transaction)\n     * This method returns the right transaction.\n     *\n     * @param data - A Uint8Array or Uint8Array[]\n     * @param txOptions - The transaction options\n     */\n  }, {\n    key: \"fromBlockBodyData\",\n    value: function fromBlockBodyData(data) {\n      var txOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (data instanceof Uint8Array) {\n        return this.fromSerializedData(data, txOptions);\n      }\n      if (Array.isArray(data)) {\n        // It is a legacy transaction\n        return Transaction.fromValuesArray(data, txOptions);\n      }\n      throw new Error('Cannot decode transaction: unknown type input');\n    }\n  }]);\n  return TransactionFactory;\n}();","map":{"version":3,"names":["toUint8Array","uint8ArrayToBigInt","FeeMarketEIP1559Transaction","AccessListEIP2930Transaction","Transaction","extraTxTypes","Map","TransactionFactory","_classCallCheck","_createClass","key","value","typeToInt","txType","Number","registerTransactionType","type","txClass","set","fromTxData","txData","txOptions","arguments","length","undefined","ExtraTransaction","get","Error","concat","fromSerializedData","data","fromSerializedTx","fromBlockBodyData","Uint8Array","Array","isArray","fromValuesArray"],"sources":["D:\\Prasanth\\CCBC2\\611 - Adoption of Cloud Computing and Blockchain\\TelecomProject\\Telcom_GitRepo\\Tfq_GitRepo\\app\\node_modules\\web3-eth-accounts\\src\\tx\\transactionFactory.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { Numbers } from 'web3-types';\nimport { toUint8Array, uint8ArrayToBigInt } from '../common/utils.js';\nimport { FeeMarketEIP1559Transaction } from './eip1559Transaction.js';\nimport { AccessListEIP2930Transaction } from './eip2930Transaction.js';\nimport { Transaction } from './legacyTransaction.js';\nimport type { TypedTransaction } from '../types.js';\n\nimport type {\n\tAccessListEIP2930TxData,\n\tFeeMarketEIP1559TxData,\n\tTxData,\n\tTxOptions,\n} from './types.js';\nimport { BaseTransaction } from './baseTransaction.js';\n\nconst extraTxTypes: Map<Numbers, typeof BaseTransaction<unknown>> = new Map();\n\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class TransactionFactory {\n\t// It is not possible to instantiate a TransactionFactory object.\n\t// eslint-disable-next-line @typescript-eslint/no-empty-function, no-useless-constructor\n\tprivate constructor() {}\n\n\tpublic static typeToInt(txType: Numbers) {\n\t\treturn Number(uint8ArrayToBigInt(toUint8Array(txType)));\n\t}\n\n\tpublic static registerTransactionType<NewTxTypeClass extends typeof BaseTransaction<unknown>>(\n\t\ttype: Numbers,\n\t\ttxClass: NewTxTypeClass,\n\t) {\n\t\tconst txType = TransactionFactory.typeToInt(type);\n\t\textraTxTypes.set(txType, txClass);\n\t}\n\n\t/**\n\t * Create a transaction from a `txData` object\n\t *\n\t * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)\n\t * @param txOptions - Options to pass on to the constructor of the transaction\n\t */\n\tpublic static fromTxData(\n\t\ttxData: TxData | TypedTransaction,\n\t\ttxOptions: TxOptions = {},\n\t): TypedTransaction {\n\t\tif (!('type' in txData) || txData.type === undefined) {\n\t\t\t// Assume legacy transaction\n\t\t\treturn Transaction.fromTxData(txData as TxData, txOptions);\n\t\t}\n\t\tconst txType = TransactionFactory.typeToInt(txData.type);\n\t\tif (txType === 0) {\n\t\t\treturn Transaction.fromTxData(txData as TxData, txOptions);\n\t\t}\n\t\tif (txType === 1) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\t\t\treturn AccessListEIP2930Transaction.fromTxData(\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\t\t\t\t<AccessListEIP2930TxData>txData,\n\t\t\t\ttxOptions,\n\t\t\t);\n\t\t}\n\t\tif (txType === 2) {\n\t\t\treturn FeeMarketEIP1559Transaction.fromTxData(\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\t\t\t\t<FeeMarketEIP1559TxData>txData,\n\t\t\t\ttxOptions,\n\t\t\t);\n\t\t}\n\t\tconst ExtraTransaction = extraTxTypes.get(txType);\n\t\tif (ExtraTransaction?.fromTxData) {\n\t\t\treturn ExtraTransaction.fromTxData(txData, txOptions) as TypedTransaction;\n\t\t}\n\n\t\tthrow new Error(`Tx instantiation with type ${txType} not supported`);\n\t}\n\n\t/**\n\t * This method tries to decode serialized data.\n\t *\n\t * @param data - The data Uint8Array\n\t * @param txOptions - The transaction options\n\t */\n\tpublic static fromSerializedData(\n\t\tdata: Uint8Array,\n\t\ttxOptions: TxOptions = {},\n\t): TypedTransaction {\n\t\tif (data[0] <= 0x7f) {\n\t\t\t// Determine the type.\n\t\t\tswitch (data[0]) {\n\t\t\t\tcase 1:\n\t\t\t\t\treturn AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);\n\t\t\t\tcase 2:\n\t\t\t\t\treturn FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);\n\t\t\t\tdefault: {\n\t\t\t\t\tconst ExtraTransaction = extraTxTypes.get(Number(data[0]));\n\t\t\t\t\tif (ExtraTransaction?.fromSerializedTx) {\n\t\t\t\t\t\treturn ExtraTransaction.fromSerializedTx(\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\ttxOptions,\n\t\t\t\t\t\t) as TypedTransaction;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(`TypedTransaction with ID ${data[0]} unknown`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn Transaction.fromSerializedTx(data, txOptions);\n\t\t}\n\t}\n\n\t/**\n\t * When decoding a BlockBody, in the transactions field, a field is either:\n\t * A Uint8Array (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))\n\t * A Uint8Array[] (Legacy Transaction)\n\t * This method returns the right transaction.\n\t *\n\t * @param data - A Uint8Array or Uint8Array[]\n\t * @param txOptions - The transaction options\n\t */\n\tpublic static fromBlockBodyData(data: Uint8Array | Uint8Array[], txOptions: TxOptions = {}) {\n\t\tif (data instanceof Uint8Array) {\n\t\t\treturn this.fromSerializedData(data, txOptions);\n\t\t}\n\t\tif (Array.isArray(data)) {\n\t\t\t// It is a legacy transaction\n\t\t\treturn Transaction.fromValuesArray(data, txOptions);\n\t\t}\n\t\tthrow new Error('Cannot decode transaction: unknown type input');\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}