{"ast":null,"code":"import _regeneratorRuntime from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ContractExecutionError, InvalidResponseError, ProviderError, ResponseError, rpcErrorsMap, RpcError } from 'web3-errors';\nimport HttpProvider from 'web3-providers-http';\nimport WSProvider from 'web3-providers-ws';\nimport { isNullish, isPromise, jsonRpc, isResponseRpcError } from 'web3-utils';\nimport { isEIP1193Provider, isLegacyRequestProvider, isLegacySendAsyncProvider, isLegacySendProvider, isWeb3Provider, isMetaMaskProvider } from './utils.js';\nimport { Web3EventEmitter } from './web3_event_emitter.js';\nexport var Web3RequestManagerEvent;\n(function (Web3RequestManagerEvent) {\n  Web3RequestManagerEvent[\"PROVIDER_CHANGED\"] = \"PROVIDER_CHANGED\";\n  Web3RequestManagerEvent[\"BEFORE_PROVIDER_CHANGE\"] = \"BEFORE_PROVIDER_CHANGE\";\n})(Web3RequestManagerEvent || (Web3RequestManagerEvent = {}));\nvar availableProviders = {\n  HttpProvider: HttpProvider,\n  WebsocketProvider: WSProvider\n};\n// if input was provided in params, change to data due to metamask only accepting data\nvar metamaskPayload = function metamaskPayload(payload) {\n  var _a;\n  if (Array.isArray(payload.params)) {\n    var params = payload.params[0];\n    if (params.input && !params.data) {\n      return Object.assign(Object.assign({}, payload), {\n        params: [Object.assign(Object.assign({}, params), {\n          data: (_a = params.data) !== null && _a !== void 0 ? _a : params.input\n        })]\n      });\n    }\n  }\n  return payload;\n};\nexport var Web3RequestManager = /*#__PURE__*/function (_Web3EventEmitter) {\n  _inherits(Web3RequestManager, _Web3EventEmitter);\n  var _super = _createSuper(Web3RequestManager);\n  function Web3RequestManager(provider, useRpcCallSpecification) {\n    var _this;\n    _classCallCheck(this, Web3RequestManager);\n    _this = _super.call(this);\n    if (!isNullish(provider)) {\n      _this.setProvider(provider);\n    }\n    _this.useRpcCallSpecification = useRpcCallSpecification;\n    return _this;\n  }\n  /**\n   * Will return all available providers\n   */\n  _createClass(Web3RequestManager, [{\n    key: \"provider\",\n    get:\n    /**\n     * Will return the current provider.\n     *\n     * @returns Returns the current provider\n     */\n    function get() {\n      return this._provider;\n    }\n    /**\n     * Will return all available providers\n     */\n    // eslint-disable-next-line class-methods-use-this\n  }, {\n    key: \"providers\",\n    get: function get() {\n      return availableProviders;\n    }\n    /**\n     * Use to set provider. Provider can be a provider instance or a string.\n     *\n     * @param provider - The provider to set\n     */\n  }, {\n    key: \"setProvider\",\n    value: function setProvider(provider) {\n      var newProvider;\n      // autodetect provider\n      if (provider && typeof provider === 'string' && this.providers) {\n        // HTTP\n        if (/^http(s)?:\\/\\//i.test(provider)) {\n          newProvider = new this.providers.HttpProvider(provider);\n          // WS\n        } else if (/^ws(s)?:\\/\\//i.test(provider)) {\n          newProvider = new this.providers.WebsocketProvider(provider);\n        } else {\n          throw new ProviderError(\"Can't autodetect provider for \\\"\".concat(provider, \"\\\"\"));\n        }\n      } else if (isNullish(provider)) {\n        // In case want to unset the provider\n        newProvider = undefined;\n      } else {\n        newProvider = provider;\n      }\n      this.emit(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, this._provider);\n      this._provider = newProvider;\n      this.emit(Web3RequestManagerEvent.PROVIDER_CHANGED, this._provider);\n      return true;\n    }\n    /**\n     *\n     * Will execute a request\n     *\n     * @param request - {@link Web3APIRequest} The request to send\n     *\n     * @returns The response of the request {@link ResponseType}. If there is error\n     * in the response, will throw an error\n     */\n  }, {\n    key: \"send\",\n    value: function send(request) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this._sendRequest(request);\n            case 2:\n              response = _context.sent;\n              if (!jsonRpc.isResponseWithResult(response)) {\n                _context.next = 5;\n                break;\n              }\n              return _context.abrupt(\"return\", response.result);\n            case 5:\n              throw new ResponseError(response);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Same as send, but, will execute a batch of requests\n     *\n     * @param request {@link JsonRpcBatchRequest} The batch request to send\n     */\n  }, {\n    key: \"sendBatch\",\n    value: function sendBatch(request) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this._sendRequest(request);\n            case 2:\n              response = _context2.sent;\n              return _context2.abrupt(\"return\", response);\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"_sendRequest\",\n    value: function _sendRequest(request) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this2 = this;\n        var provider, payload, response;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              provider = this.provider;\n              if (!isNullish(provider)) {\n                _context3.next = 3;\n                break;\n              }\n              throw new ProviderError('Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.');\n            case 3:\n              payload = jsonRpc.isBatchRequest(request) ? jsonRpc.toBatchPayload(request) : jsonRpc.toPayload(request);\n              if (isMetaMaskProvider(provider)) {\n                // metamask send_transaction accepts data and not input, so we change it\n                if (payload.method === 'eth_sendTransaction') {\n                  if (!jsonRpc.isBatchRequest(payload)) {\n                    payload = metamaskPayload(payload);\n                  } else {\n                    payload = payload.map(function (p) {\n                      return metamaskPayload(p);\n                    });\n                  }\n                }\n              }\n              if (!isWeb3Provider(provider)) {\n                _context3.next = 16;\n                break;\n              }\n              _context3.prev = 6;\n              _context3.next = 9;\n              return provider.request(payload);\n            case 9:\n              response = _context3.sent;\n              _context3.next = 15;\n              break;\n            case 12:\n              _context3.prev = 12;\n              _context3.t0 = _context3[\"catch\"](6);\n              // Check if the provider throw an error instead of reject with error\n              response = _context3.t0;\n            case 15:\n              return _context3.abrupt(\"return\", this._processJsonRpcResponse(payload, response, {\n                legacy: false,\n                error: false\n              }));\n            case 16:\n              if (!isEIP1193Provider(provider)) {\n                _context3.next = 18;\n                break;\n              }\n              return _context3.abrupt(\"return\", provider.request(payload).then(function (res) {\n                return _this2._processJsonRpcResponse(payload, res, {\n                  legacy: true,\n                  error: false\n                });\n              }).catch(function (error) {\n                return _this2._processJsonRpcResponse(payload, error, {\n                  legacy: true,\n                  error: true\n                });\n              }));\n            case 18:\n              if (!isLegacyRequestProvider(provider)) {\n                _context3.next = 20;\n                break;\n              }\n              return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                var rejectWithError = function rejectWithError(err) {\n                  return reject(_this2._processJsonRpcResponse(payload, err, {\n                    legacy: true,\n                    error: true\n                  }));\n                };\n                var resolveWithResponse = function resolveWithResponse(response) {\n                  return resolve(_this2._processJsonRpcResponse(payload, response, {\n                    legacy: true,\n                    error: false\n                  }));\n                };\n                var result = provider.request(payload,\n                // a callback that is expected to be called after getting the response:\n                function (err, response) {\n                  if (err) {\n                    return rejectWithError(err);\n                  }\n                  return resolveWithResponse(response);\n                });\n                // Some providers, that follow a previous drafted version of EIP1193, has a `request` function\n                //\tthat is not defined as `async`, but it returns a promise.\n                // Such providers would not be picked with if(isEIP1193Provider(provider)) above\n                //\tbecause the `request` function was not defined with `async` and so the function definition is not `AsyncFunction`.\n                // Like this provider: https://github.dev/NomicFoundation/hardhat/blob/62bea2600785595ba36f2105564076cf5cdf0fd8/packages/hardhat-core/src/internal/core/providers/backwards-compatibility.ts#L19\n                // So check if the returned result is a Promise, and resolve with it accordingly.\n                // Note: in this case we expect the callback provided above to never be called.\n                if (isPromise(result)) {\n                  var responsePromise = result;\n                  responsePromise.then(resolveWithResponse).catch(rejectWithError);\n                }\n              }));\n            case 20:\n              if (!isLegacySendProvider(provider)) {\n                _context3.next = 22;\n                break;\n              }\n              return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                provider.send(payload, function (err, response) {\n                  if (err) {\n                    return reject(_this2._processJsonRpcResponse(payload, err, {\n                      legacy: true,\n                      error: true\n                    }));\n                  }\n                  if (isNullish(response)) {\n                    throw new ResponseError('', 'Got a \"nullish\" response from provider.');\n                  }\n                  return resolve(_this2._processJsonRpcResponse(payload, response, {\n                    legacy: true,\n                    error: false\n                  }));\n                });\n              }));\n            case 22:\n              if (!isLegacySendAsyncProvider(provider)) {\n                _context3.next = 24;\n                break;\n              }\n              return _context3.abrupt(\"return\", provider.sendAsync(payload).then(function (response) {\n                return _this2._processJsonRpcResponse(payload, response, {\n                  legacy: true,\n                  error: false\n                });\n              }).catch(function (error) {\n                return _this2._processJsonRpcResponse(payload, error, {\n                  legacy: true,\n                  error: true\n                });\n              }));\n            case 24:\n              throw new ProviderError('Provider does not have a request or send method to use.');\n            case 25:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[6, 12]]);\n      }));\n    }\n    // eslint-disable-next-line class-methods-use-this\n  }, {\n    key: \"_processJsonRpcResponse\",\n    value: function _processJsonRpcResponse(payload, response, _ref) {\n      var legacy = _ref.legacy,\n        error = _ref.error;\n      if (isNullish(response)) {\n        return this._buildResponse(payload,\n        // Some providers uses \"null\" as valid empty response\n        // eslint-disable-next-line no-null/no-null\n        null, error);\n      }\n      // This is the majority of the cases so check these first\n      // A valid JSON-RPC response with error object\n      if (jsonRpc.isResponseWithError(response)) {\n        // check if its an rpc error\n        if (this.useRpcCallSpecification && isResponseRpcError(response)) {\n          var rpcErrorResponse = response;\n          // check if rpc error flag is on and response error code match an EIP-1474 or a standard rpc error code\n          if (rpcErrorsMap.get(rpcErrorResponse.error.code)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            var Err = rpcErrorsMap.get(rpcErrorResponse.error.code).error;\n            throw new Err(rpcErrorResponse);\n          } else {\n            throw new RpcError(rpcErrorResponse);\n          }\n        } else if (!Web3RequestManager._isReverted(response)) {\n          throw new InvalidResponseError(response, payload);\n        }\n      }\n      // This is the majority of the cases so check these first\n      // A valid JSON-RPC response with result object\n      if (jsonRpc.isResponseWithResult(response)) {\n        return response;\n      }\n      if (response instanceof Error) {\n        Web3RequestManager._isReverted(response);\n        throw response;\n      }\n      if (!legacy && jsonRpc.isBatchRequest(payload) && jsonRpc.isBatchResponse(response)) {\n        return response;\n      }\n      if (legacy && !error && jsonRpc.isBatchRequest(payload)) {\n        return response;\n      }\n      if (legacy && error && jsonRpc.isBatchRequest(payload)) {\n        // In case of error batch response we don't want to throw Invalid response\n        throw response;\n      }\n      if (legacy && !jsonRpc.isResponseWithError(response) && !jsonRpc.isResponseWithResult(response)) {\n        return this._buildResponse(payload, response, error);\n      }\n      if (jsonRpc.isBatchRequest(payload) && !Array.isArray(response)) {\n        throw new ResponseError(response, 'Got normal response for a batch request.');\n      }\n      if (!jsonRpc.isBatchRequest(payload) && Array.isArray(response)) {\n        throw new ResponseError(response, 'Got batch response for a normal request.');\n      }\n      if ((jsonRpc.isResponseWithError(response) || jsonRpc.isResponseWithResult(response)) && !jsonRpc.isBatchRequest(payload)) {\n        if (response.id && payload.id !== response.id) {\n          throw new InvalidResponseError(response);\n        }\n      }\n      throw new ResponseError(response, 'Invalid response');\n    }\n  }, {\n    key: \"_buildResponse\",\n    value:\n    // Need to use same types as _processJsonRpcResponse so have to declare as instance method\n    // eslint-disable-next-line class-methods-use-this\n    function _buildResponse(payload, response, error) {\n      var res = {\n        jsonrpc: '2.0',\n        // eslint-disable-next-line no-nested-ternary\n        id: jsonRpc.isBatchRequest(payload) ? payload[0].id : 'id' in payload ? payload.id :\n        // Have to use the null here explicitly\n        // eslint-disable-next-line no-null/no-null\n        null\n      };\n      if (error) {\n        return Object.assign(Object.assign({}, res), {\n          error: response\n        });\n      }\n      return Object.assign(Object.assign({}, res), {\n        result: response\n      });\n    }\n  }], [{\n    key: \"providers\",\n    get: function get() {\n      return availableProviders;\n    }\n  }, {\n    key: \"_isReverted\",\n    value: function _isReverted(response) {\n      var error;\n      if (jsonRpc.isResponseWithError(response)) {\n        error = response.error;\n      } else if (response instanceof Error) {\n        error = response;\n      }\n      // This message means that there was an error while executing the code of the smart contract\n      // However, more processing will happen at a higher level to decode the error data,\n      //\taccording to the Error ABI, if it was available as of EIP-838.\n      if (error === null || error === void 0 ? void 0 : error.message.includes('revert')) throw new ContractExecutionError(error);\n      return false;\n    }\n  }]);\n  return Web3RequestManager;\n}(Web3EventEmitter);","map":{"version":3,"names":["ContractExecutionError","InvalidResponseError","ProviderError","ResponseError","rpcErrorsMap","RpcError","HttpProvider","WSProvider","isNullish","isPromise","jsonRpc","isResponseRpcError","isEIP1193Provider","isLegacyRequestProvider","isLegacySendAsyncProvider","isLegacySendProvider","isWeb3Provider","isMetaMaskProvider","Web3EventEmitter","Web3RequestManagerEvent","availableProviders","WebsocketProvider","metamaskPayload","payload","Array","isArray","params","input","data","Object","assign","_a","Web3RequestManager","_Web3EventEmitter","_inherits","_super","_createSuper","provider","useRpcCallSpecification","_this","_classCallCheck","call","setProvider","_createClass","key","get","_provider","value","newProvider","providers","test","concat","undefined","emit","BEFORE_PROVIDER_CHANGE","PROVIDER_CHANGED","send","request","_sendRequest","response","_context","sent","isResponseWithResult","next","abrupt","result","stop","_callee","sendBatch","_context2","_callee2","_context3","isBatchRequest","toBatchPayload","toPayload","method","map","p","prev","t0","_processJsonRpcResponse","legacy","error","then","res","_this2","catch","Promise","resolve","reject","rejectWithError","err","resolveWithResponse","responsePromise","sendAsync","_callee3","_ref","_buildResponse","isResponseWithError","rpcErrorResponse","code","Err","_isReverted","Error","isBatchResponse","id","jsonrpc","message","includes"],"sources":["D:\\Prasanth\\CCBC2\\611 - Adoption of Cloud Computing and Blockchain\\TelecomProject\\Telcom_GitRepo\\Tfq_GitRepo\\app\\node_modules\\web3-core\\src\\web3_request_manager.ts"],"sourcesContent":["﻿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport {\n\tContractExecutionError,\n\tInvalidResponseError,\n\tProviderError,\n\tResponseError,\n\trpcErrorsMap,\n\tRpcError,\n} from 'web3-errors';\nimport HttpProvider from 'web3-providers-http';\nimport WSProvider from 'web3-providers-ws';\nimport {\n\tEthExecutionAPI,\n\tJsonRpcBatchRequest,\n\tJsonRpcBatchResponse,\n\tJsonRpcPayload,\n\tJsonRpcResponse,\n\tJsonRpcError,\n\tJsonRpcResponseWithResult,\n\tJsonRpcResponseWithError,\n\tSupportedProviders,\n\tWeb3APIMethod,\n\tWeb3APIPayload,\n\tWeb3APIRequest,\n\tWeb3APIReturnType,\n\tWeb3APISpec,\n\tWeb3BaseProvider,\n\tWeb3BaseProviderConstructor,\n\tJsonRpcRequest\n} from 'web3-types';\nimport { isNullish, isPromise, jsonRpc, isResponseRpcError } from 'web3-utils';\nimport {\n\tisEIP1193Provider,\n\tisLegacyRequestProvider,\n\tisLegacySendAsyncProvider,\n\tisLegacySendProvider,\n\tisWeb3Provider,\n\tisMetaMaskProvider,\n} from './utils.js';\nimport { Web3EventEmitter } from './web3_event_emitter.js';\n\nexport enum Web3RequestManagerEvent {\n\tPROVIDER_CHANGED = 'PROVIDER_CHANGED',\n\tBEFORE_PROVIDER_CHANGE = 'BEFORE_PROVIDER_CHANGE',\n}\n\nconst availableProviders: {\n\tHttpProvider: Web3BaseProviderConstructor;\n\tWebsocketProvider: Web3BaseProviderConstructor;\n} = {\n\tHttpProvider: HttpProvider as Web3BaseProviderConstructor,\n\tWebsocketProvider: WSProvider as Web3BaseProviderConstructor,\n};\n\n\n// if input was provided in params, change to data due to metamask only accepting data\nconst metamaskPayload = (payload: JsonRpcRequest) => {\n\t\n\tif(Array.isArray(payload.params)) {\n\tconst params = payload.params[0] as Record<string, unknown>\n\tif (params.input && !params.data) {\n\n\t\treturn {...payload,\n\t\t\tparams: [{...params,\n\t\t\t\tdata: params.data ?? params.input}]\n\t\t}\n\t}\n}\nreturn payload;\n\n}\n\nexport class Web3RequestManager<\n\tAPI extends Web3APISpec = EthExecutionAPI,\n> extends Web3EventEmitter<{\n\t[key in Web3RequestManagerEvent]: SupportedProviders<API> | undefined;\n}> {\n\tprivate _provider?: SupportedProviders<API>;\n\tprivate readonly useRpcCallSpecification?: boolean;\n\tpublic constructor(\n\t\tprovider?: SupportedProviders<API> | string,\n\t\tuseRpcCallSpecification?: boolean,\n\t) {\n\t\tsuper();\n\n\t\tif (!isNullish(provider)) {\n\t\t\tthis.setProvider(provider);\n\t\t}\n\t\tthis.useRpcCallSpecification = useRpcCallSpecification;\n\t}\n\n\t/**\n\t * Will return all available providers\n\t */\n\tpublic static get providers() {\n\t\treturn availableProviders;\n\t}\n\n\t/**\n\t * Will return the current provider.\n\t *\n\t * @returns Returns the current provider\n\t */\n\tpublic get provider() {\n\t\treturn this._provider;\n\t}\n\n\t/**\n\t * Will return all available providers\n\t */\n\t// eslint-disable-next-line class-methods-use-this\n\tpublic get providers() {\n\t\treturn availableProviders;\n\t}\n\n\t/**\n\t * Use to set provider. Provider can be a provider instance or a string.\n\t *\n\t * @param provider - The provider to set\n\t */\n\tpublic setProvider(provider?: SupportedProviders<API> | string): boolean {\n\t\tlet newProvider: SupportedProviders<API> | undefined;\n\n\t\t// autodetect provider\n\t\tif (provider && typeof provider === 'string' && this.providers) {\n\t\t\t// HTTP\n\t\t\tif (/^http(s)?:\\/\\//i.test(provider)) {\n\t\t\t\tnewProvider = new this.providers.HttpProvider<API>(provider);\n\n\t\t\t\t// WS\n\t\t\t} else if (/^ws(s)?:\\/\\//i.test(provider)) {\n\t\t\t\tnewProvider = new this.providers.WebsocketProvider<API>(provider);\n\t\t\t} else {\n\t\t\t\tthrow new ProviderError(`Can't autodetect provider for \"${provider}\"`);\n\t\t\t}\n\t\t} else if (isNullish(provider)) {\n\t\t\t// In case want to unset the provider\n\t\t\tnewProvider = undefined;\n\t\t} else {\n\t\t\tnewProvider = provider as SupportedProviders<API>;\n\t\t}\n\n\t\tthis.emit(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, this._provider);\n\t\tthis._provider = newProvider;\n\t\tthis.emit(Web3RequestManagerEvent.PROVIDER_CHANGED, this._provider);\n\t\treturn true;\n\t}\n\n\t/**\n\t *\n\t * Will execute a request\n\t *\n\t * @param request - {@link Web3APIRequest} The request to send\n\t *\n\t * @returns The response of the request {@link ResponseType}. If there is error\n\t * in the response, will throw an error\n\t */\n\tpublic async send<\n\t\tMethod extends Web3APIMethod<API>,\n\t\tResponseType = Web3APIReturnType<API, Method>,\n\t>(request: Web3APIRequest<API, Method>): Promise<ResponseType> {\n\t\tconst response = await this._sendRequest<Method, ResponseType>(request);\n\t\tif (jsonRpc.isResponseWithResult(response)) {\n\t\t\treturn response.result;\n\t\t}\n\n\t\tthrow new ResponseError(response);\n\t}\n\n\t/**\n\t * Same as send, but, will execute a batch of requests\n\t *\n\t * @param request {@link JsonRpcBatchRequest} The batch request to send\n\t */\n\tpublic async sendBatch(request: JsonRpcBatchRequest): Promise<JsonRpcBatchResponse<unknown>> {\n\t\tconst response = await this._sendRequest<never, never>(request);\n\n\t\treturn response as JsonRpcBatchResponse<unknown>;\n\t}\n\n\tprivate async _sendRequest<\n\t\tMethod extends Web3APIMethod<API>,\n\t\tResponseType = Web3APIReturnType<API, Method>,\n\t>(\n\t\trequest: Web3APIRequest<API, Method> | JsonRpcBatchRequest,\n\t): Promise<JsonRpcResponse<ResponseType>> {\n\t\tconst { provider } = this;\n\n\t\tif (isNullish(provider)) {\n\t\t\tthrow new ProviderError(\n\t\t\t\t'Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.',\n\t\t\t);\n\t\t}\n\t\t\n\t\tlet payload = jsonRpc.isBatchRequest(request)\n\t\t\t? jsonRpc.toBatchPayload(request)\n\t\t\t: jsonRpc.toPayload(request);\n\t\t\t\n\t\tif(isMetaMaskProvider(provider)){ // metamask send_transaction accepts data and not input, so we change it\n\t\t\tif ((payload as JsonRpcRequest<ResponseType>).method === 'eth_sendTransaction'){\n\t\t\t\tif(!jsonRpc.isBatchRequest(payload)){\n\t\t\t\t\tpayload = metamaskPayload(payload as JsonRpcRequest)\n\t\t\t\t} else {\n\t\t\t\t\tpayload = payload.map(p => metamaskPayload(p as JsonRpcRequest))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (isWeb3Provider(provider)) {\n\t\t\tlet response;\n\n\t\t\ttry {\n\t\t\t\tresponse = await provider.request<Method, ResponseType>(\n\t\t\t\t\tpayload as Web3APIPayload<API, Method>,\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\t// Check if the provider throw an error instead of reject with error\n\t\t\t\tresponse = error as JsonRpcResponse<ResponseType>;\n\t\t\t}\n\t\t\treturn this._processJsonRpcResponse(payload, response, { legacy: false, error: false });\n\t\t}\n\n\t\tif (isEIP1193Provider(provider)) {\n\t\t\treturn (provider as Web3BaseProvider<API>)\n\t\t\t\t.request<Method, ResponseType>(payload as Web3APIPayload<API, Method>)\n\t\t\t\t.then(\n\t\t\t\t\tres =>\n\t\t\t\t\t\tthis._processJsonRpcResponse(payload, res, {\n\t\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\t\terror: false,\n\t\t\t\t\t\t}) as JsonRpcResponseWithResult<ResponseType>,\n\t\t\t\t)\n\t\t\t\t.catch(error =>\n\t\t\t\t\tthis._processJsonRpcResponse(\n\t\t\t\t\t\tpayload,\n\t\t\t\t\t\terror as JsonRpcResponse<ResponseType, unknown>,\n\t\t\t\t\t\t{ legacy: true, error: true },\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t}\n\n\t\t// TODO: This could be deprecated and removed.\n\t\tif (isLegacyRequestProvider(provider)) {\n\t\t\treturn new Promise<JsonRpcResponse<ResponseType>>((resolve, reject) => {\n\t\t\t\tconst rejectWithError = (err: unknown) =>\n\t\t\t\t\treject(\n\t\t\t\t\t\tthis._processJsonRpcResponse(\n\t\t\t\t\t\t\tpayload,\n\t\t\t\t\t\t\terr as JsonRpcResponse<ResponseType>,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\t\t\terror: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\tconst resolveWithResponse = (response: JsonRpcResponse<ResponseType>) =>\n\t\t\t\t\tresolve(\n\t\t\t\t\t\tthis._processJsonRpcResponse(payload, response, {\n\t\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\t\terror: false,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\tconst result = provider.request<ResponseType>(\n\t\t\t\t\tpayload,\n\t\t\t\t\t// a callback that is expected to be called after getting the response:\n\t\t\t\t\t(err, response) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn rejectWithError(err);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn resolveWithResponse(response);\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\t// Some providers, that follow a previous drafted version of EIP1193, has a `request` function\n\t\t\t\t//\tthat is not defined as `async`, but it returns a promise.\n\t\t\t\t// Such providers would not be picked with if(isEIP1193Provider(provider)) above\n\t\t\t\t//\tbecause the `request` function was not defined with `async` and so the function definition is not `AsyncFunction`.\n\t\t\t\t// Like this provider: https://github.dev/NomicFoundation/hardhat/blob/62bea2600785595ba36f2105564076cf5cdf0fd8/packages/hardhat-core/src/internal/core/providers/backwards-compatibility.ts#L19\n\t\t\t\t// So check if the returned result is a Promise, and resolve with it accordingly.\n\t\t\t\t// Note: in this case we expect the callback provided above to never be called.\n\t\t\t\tif (isPromise(result)) {\n\t\t\t\t\tconst responsePromise = result as unknown as Promise<\n\t\t\t\t\t\tJsonRpcResponse<ResponseType>\n\t\t\t\t\t>;\n\t\t\t\t\tresponsePromise.then(resolveWithResponse).catch(rejectWithError);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// TODO: This could be deprecated and removed.\n\t\tif (isLegacySendProvider(provider)) {\n\t\t\treturn new Promise<JsonRpcResponse<ResponseType>>((resolve, reject): void => {\n\t\t\t\tprovider.send<ResponseType>(payload, (err, response) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\tthis._processJsonRpcResponse(\n\t\t\t\t\t\t\t\tpayload,\n\t\t\t\t\t\t\t\terr as unknown as JsonRpcResponse<ResponseType>,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\t\t\t\terror: true,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isNullish(response)) {\n\t\t\t\t\t\tthrow new ResponseError(\n\t\t\t\t\t\t\t'' as never,\n\t\t\t\t\t\t\t'Got a \"nullish\" response from provider.',\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve(\n\t\t\t\t\t\tthis._processJsonRpcResponse(payload, response, {\n\t\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\t\terror: false,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// TODO: This could be deprecated and removed.\n\t\tif (isLegacySendAsyncProvider(provider)) {\n\t\t\treturn provider\n\t\t\t\t.sendAsync<ResponseType>(payload)\n\t\t\t\t.then(response =>\n\t\t\t\t\tthis._processJsonRpcResponse(payload, response, { legacy: true, error: false }),\n\t\t\t\t)\n\t\t\t\t.catch(error =>\n\t\t\t\t\tthis._processJsonRpcResponse(payload, error as JsonRpcResponse<ResponseType>, {\n\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\terror: true,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t}\n\n\t\tthrow new ProviderError('Provider does not have a request or send method to use.');\n\t}\n\n\t// eslint-disable-next-line class-methods-use-this\n\tprivate _processJsonRpcResponse<ResultType, ErrorType, RequestType>(\n\t\tpayload: JsonRpcPayload<RequestType>,\n\t\tresponse: JsonRpcResponse<ResultType, ErrorType>,\n\t\t{ legacy, error }: { legacy: boolean; error: boolean },\n\t): JsonRpcResponse<ResultType> | never {\n\t\tif (isNullish(response)) {\n\t\t\treturn this._buildResponse(\n\t\t\t\tpayload,\n\t\t\t\t// Some providers uses \"null\" as valid empty response\n\t\t\t\t// eslint-disable-next-line no-null/no-null\n\t\t\t\tnull as unknown as JsonRpcResponse<ResultType, ErrorType>,\n\t\t\t\terror,\n\t\t\t);\n\t\t}\n\n\t\t// This is the majority of the cases so check these first\n\t\t// A valid JSON-RPC response with error object\n\t\tif (jsonRpc.isResponseWithError<ErrorType>(response)) {\n\t\t\t// check if its an rpc error\n\t\t\tif (\n\t\t\t\tthis.useRpcCallSpecification &&\n\t\t\t\tisResponseRpcError(response as JsonRpcResponseWithError)\n\t\t\t) {\n\t\t\t\tconst rpcErrorResponse = response as JsonRpcResponseWithError;\n\t\t\t\t// check if rpc error flag is on and response error code match an EIP-1474 or a standard rpc error code\n\t\t\t\tif (rpcErrorsMap.get(rpcErrorResponse.error.code)) {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t\t\tconst Err = rpcErrorsMap.get(rpcErrorResponse.error.code)!.error;\n\t\t\t\t\tthrow new Err(rpcErrorResponse);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new RpcError(rpcErrorResponse);\n\t\t\t\t}\n\t\t\t} else if (!Web3RequestManager._isReverted(response)) {\n\t\t\t\tthrow new InvalidResponseError<ErrorType, RequestType>(response, payload);\n\t\t\t}\n\t\t}\n\n\t\t// This is the majority of the cases so check these first\n\t\t// A valid JSON-RPC response with result object\n\t\tif (jsonRpc.isResponseWithResult<ResultType>(response)) {\n\t\t\treturn response;\n\t\t}\n\n\t\tif ((response as unknown) instanceof Error) {\n\t\t\tWeb3RequestManager._isReverted(response);\n\t\t\tthrow response;\n\t\t}\n\n\t\tif (!legacy && jsonRpc.isBatchRequest(payload) && jsonRpc.isBatchResponse(response)) {\n\t\t\treturn response as JsonRpcBatchResponse<ResultType>;\n\t\t}\n\n\t\tif (legacy && !error && jsonRpc.isBatchRequest(payload)) {\n\t\t\treturn response as JsonRpcBatchResponse<ResultType>;\n\t\t}\n\n\t\tif (legacy && error && jsonRpc.isBatchRequest(payload)) {\n\t\t\t// In case of error batch response we don't want to throw Invalid response\n\t\t\tthrow response;\n\t\t}\n\n\t\tif (\n\t\t\tlegacy &&\n\t\t\t!jsonRpc.isResponseWithError(response) &&\n\t\t\t!jsonRpc.isResponseWithResult(response)\n\t\t) {\n\t\t\treturn this._buildResponse(payload, response, error);\n\t\t}\n\n\t\tif (jsonRpc.isBatchRequest(payload) && !Array.isArray(response)) {\n\t\t\tthrow new ResponseError(response, 'Got normal response for a batch request.');\n\t\t}\n\n\t\tif (!jsonRpc.isBatchRequest(payload) && Array.isArray(response)) {\n\t\t\tthrow new ResponseError(response, 'Got batch response for a normal request.');\n\t\t}\n\n\t\tif (\n\t\t\t(jsonRpc.isResponseWithError(response) || jsonRpc.isResponseWithResult(response)) &&\n\t\t\t!jsonRpc.isBatchRequest(payload)\n\t\t) {\n\t\t\tif (response.id && payload.id !== response.id) {\n\t\t\t\tthrow new InvalidResponseError<ErrorType>(response);\n\t\t\t}\n\t\t}\n\n\t\tthrow new ResponseError(response, 'Invalid response');\n\t}\n\n\tprivate static _isReverted<ResultType, ErrorType>(\n\t\tresponse: JsonRpcResponse<ResultType, ErrorType>,\n\t): boolean {\n\t\tlet error: JsonRpcError | undefined;\n\n\t\tif (jsonRpc.isResponseWithError<ErrorType>(response)) {\n\t\t\terror = (response as JsonRpcResponseWithError).error;\n\t\t} else if ((response as unknown) instanceof Error) {\n\t\t\terror = response as unknown as JsonRpcError;\n\t\t}\n\n\t\t// This message means that there was an error while executing the code of the smart contract\n\t\t// However, more processing will happen at a higher level to decode the error data,\n\t\t//\taccording to the Error ABI, if it was available as of EIP-838.\n\t\tif (error?.message.includes('revert')) throw new ContractExecutionError(error);\n\n\t\treturn false;\n\t}\n\t// Need to use same types as _processJsonRpcResponse so have to declare as instance method\n\t// eslint-disable-next-line class-methods-use-this\n\tprivate _buildResponse<ResultType, ErrorType, RequestType>(\n\t\tpayload: JsonRpcPayload<RequestType>,\n\t\tresponse: JsonRpcResponse<ResultType, ErrorType>,\n\t\terror: boolean,\n\t): JsonRpcResponse<ResultType> {\n\t\tconst res = {\n\t\t\tjsonrpc: '2.0',\n\t\t\t// eslint-disable-next-line no-nested-ternary\n\t\t\tid: jsonRpc.isBatchRequest(payload)\n\t\t\t\t? payload[0].id\n\t\t\t\t: 'id' in payload\n\t\t\t\t? payload.id\n\t\t\t\t: // Have to use the null here explicitly\n\t\t\t\t  // eslint-disable-next-line no-null/no-null\n\t\t\t\t  null,\n\t\t};\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\t...res,\n\t\t\t\terror: response as unknown,\n\t\t\t} as JsonRpcResponse<ResultType>;\n\t\t}\n\n\t\treturn {\n\t\t\t...res,\n\t\t\tresult: response as unknown,\n\t\t} as JsonRpcResponse<ResultType>;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}