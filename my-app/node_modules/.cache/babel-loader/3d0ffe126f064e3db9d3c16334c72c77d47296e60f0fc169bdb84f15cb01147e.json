{"ast":null,"code":"import _slicedToArray from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _wrapRegExp from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/wrapRegExp.js\";\nimport _toConsumableArray from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createClass from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport { bytesRegex, execTyped, integerRegex, isTupleRegex } from \"./chunk-WP7KDV47.mjs\";\nimport { __publicField } from \"./chunk-NHABU752.mjs\";\n\n// package.json\nvar name = \"abitype\";\nvar version = \"0.7.1\";\n\n// src/errors.ts\nvar BaseError = /*#__PURE__*/function (_Error) {\n  _inherits(BaseError, _Error);\n  var _super = _createSuper(BaseError);\n  function BaseError(shortMessage) {\n    var _args$cause;\n    var _this;\n    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, BaseError);\n    var details = args.cause instanceof BaseError ? args.cause.details : (_args$cause = args.cause) !== null && _args$cause !== void 0 && _args$cause.message ? args.cause.message : args.details;\n    var docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;\n    var message = [shortMessage || \"An error occurred.\", \"\"].concat(_toConsumableArray(args.metaMessages ? [].concat(_toConsumableArray(args.metaMessages), [\"\"]) : []), _toConsumableArray(docsPath ? [\"Docs: https://abitype.dev\".concat(docsPath)] : []), _toConsumableArray(details ? [\"Details: \".concat(details)] : []), [\"Version: \".concat(name, \"@\").concat(version)]).join(\"\\n\");\n    _this = _super.call(this, message);\n    __publicField(_assertThisInitialized(_this), \"details\");\n    __publicField(_assertThisInitialized(_this), \"docsPath\");\n    __publicField(_assertThisInitialized(_this), \"metaMessages\");\n    __publicField(_assertThisInitialized(_this), \"shortMessage\");\n    __publicField(_assertThisInitialized(_this), \"name\", \"AbiTypeError\");\n    if (args.cause) _this.cause = args.cause;\n    _this.details = details;\n    _this.docsPath = docsPath;\n    _this.metaMessages = args.metaMessages;\n    _this.shortMessage = shortMessage;\n    return _this;\n  }\n  return _createClass(BaseError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\n// src/narrow.ts\nfunction narrow(value) {\n  return value;\n}\n\n// src/human-readable/runtime/signatures.ts\nvar errorSignatureRegex = /*#__PURE__*/_wrapRegExp(/^error ([a-zA-Z0-9_]+)\\((.*?)\\)$/, {\n  name: 1,\n  parameters: 2\n});\nfunction isErrorSignature(signature) {\n  return errorSignatureRegex.test(signature);\n}\nfunction execErrorSignature(signature) {\n  return execTyped(errorSignatureRegex, signature);\n}\nvar eventSignatureRegex = /*#__PURE__*/_wrapRegExp(/^event ([a-zA-Z0-9_]+)\\((.*?)\\)$/, {\n  name: 1,\n  parameters: 2\n});\nfunction isEventSignature(signature) {\n  return eventSignatureRegex.test(signature);\n}\nfunction execEventSignature(signature) {\n  return execTyped(eventSignatureRegex, signature);\n}\nvar functionSignatureRegex = /*#__PURE__*/_wrapRegExp(/^function ([a-zA-Z0-9_]+)\\((.*?)\\)(?: (external|public{1}))?(?: (pure|view|nonpayable|payable{1}))?(?: returns \\((.*?)\\))?$/, {\n  name: 1,\n  parameters: 2,\n  scope: 3,\n  stateMutability: 4,\n  returns: 5\n});\nfunction isFunctionSignature(signature) {\n  return functionSignatureRegex.test(signature);\n}\nfunction execFunctionSignature(signature) {\n  return execTyped(functionSignatureRegex, signature);\n}\nvar structSignatureRegex = /*#__PURE__*/_wrapRegExp(/^struct ([a-zA-Z0-9_]+) \\{(.*?)\\}$/, {\n  name: 1,\n  properties: 2\n});\nfunction isStructSignature(signature) {\n  return structSignatureRegex.test(signature);\n}\nfunction execStructSignature(signature) {\n  return execTyped(structSignatureRegex, signature);\n}\nvar constructorSignatureRegex = /*#__PURE__*/_wrapRegExp(/^constructor\\((.*?)\\)(?:\\s(payable{1}))?$/, {\n  parameters: 1,\n  stateMutability: 2\n});\nfunction isConstructorSignature(signature) {\n  return constructorSignatureRegex.test(signature);\n}\nfunction execConstructorSignature(signature) {\n  return execTyped(constructorSignatureRegex, signature);\n}\nvar fallbackSignatureRegex = /^fallback\\(\\)$/;\nfunction isFallbackSignature(signature) {\n  return fallbackSignatureRegex.test(signature);\n}\nvar receiveSignatureRegex = /^receive\\(\\) external payable$/;\nfunction isReceiveSignature(signature) {\n  return receiveSignatureRegex.test(signature);\n}\nvar modifiers = /* @__PURE__ */new Set([\"memory\", \"indexed\", \"storage\", \"calldata\"]);\nvar eventModifiers = /* @__PURE__ */new Set([\"indexed\"]);\nvar functionModifiers = /* @__PURE__ */new Set([\"calldata\", \"memory\", \"storage\"]);\n\n// src/human-readable/runtime/cache.ts\nfunction getParameterCacheKey(param, type) {\n  if (type) return \"\".concat(type, \":\").concat(param);\n  return param;\n}\nvar parameterCache = /* @__PURE__ */new Map([\n// Unnamed\n[\"address\", {\n  type: \"address\"\n}], [\"bool\", {\n  type: \"bool\"\n}], [\"bytes\", {\n  type: \"bytes\"\n}], [\"bytes32\", {\n  type: \"bytes32\"\n}], [\"int\", {\n  type: \"int256\"\n}], [\"int256\", {\n  type: \"int256\"\n}], [\"string\", {\n  type: \"string\"\n}], [\"uint\", {\n  type: \"uint256\"\n}], [\"uint8\", {\n  type: \"uint8\"\n}], [\"uint16\", {\n  type: \"uint16\"\n}], [\"uint24\", {\n  type: \"uint24\"\n}], [\"uint32\", {\n  type: \"uint32\"\n}], [\"uint64\", {\n  type: \"uint64\"\n}], [\"uint96\", {\n  type: \"uint96\"\n}], [\"uint112\", {\n  type: \"uint112\"\n}], [\"uint160\", {\n  type: \"uint160\"\n}], [\"uint192\", {\n  type: \"uint192\"\n}], [\"uint256\", {\n  type: \"uint256\"\n}],\n// Named\n[\"address owner\", {\n  type: \"address\",\n  name: \"owner\"\n}], [\"address to\", {\n  type: \"address\",\n  name: \"to\"\n}], [\"bool approved\", {\n  type: \"bool\",\n  name: \"approved\"\n}], [\"bytes _data\", {\n  type: \"bytes\",\n  name: \"_data\"\n}], [\"bytes data\", {\n  type: \"bytes\",\n  name: \"data\"\n}], [\"bytes signature\", {\n  type: \"bytes\",\n  name: \"signature\"\n}], [\"bytes32 hash\", {\n  type: \"bytes32\",\n  name: \"hash\"\n}], [\"bytes32 r\", {\n  type: \"bytes32\",\n  name: \"r\"\n}], [\"bytes32 root\", {\n  type: \"bytes32\",\n  name: \"root\"\n}], [\"bytes32 s\", {\n  type: \"bytes32\",\n  name: \"s\"\n}], [\"string name\", {\n  type: \"string\",\n  name: \"name\"\n}], [\"string symbol\", {\n  type: \"string\",\n  name: \"symbol\"\n}], [\"string tokenURI\", {\n  type: \"string\",\n  name: \"tokenURI\"\n}], [\"uint tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\"\n}], [\"uint8 v\", {\n  type: \"uint8\",\n  name: \"v\"\n}], [\"uint256 balance\", {\n  type: \"uint256\",\n  name: \"balance\"\n}], [\"uint256 tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\"\n}], [\"uint256 value\", {\n  type: \"uint256\",\n  name: \"value\"\n}],\n// Indexed\n[\"event:address indexed from\", {\n  type: \"address\",\n  name: \"from\",\n  indexed: true\n}], [\"event:address indexed to\", {\n  type: \"address\",\n  name: \"to\",\n  indexed: true\n}], [\"event:uint indexed tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\",\n  indexed: true\n}], [\"event:uint256 indexed tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\",\n  indexed: true\n}]]);\n\n// src/human-readable/runtime/utils.ts\nfunction parseSignature(signature) {\n  var structs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (isFunctionSignature(signature)) {\n    var _match$stateMutabilit;\n    var match = execFunctionSignature(signature);\n    if (!match) throw new BaseError(\"Invalid function signature.\", {\n      details: signature\n    });\n    var inputParams = splitParameters(match.parameters);\n    var inputs = [];\n    var inputLength = inputParams.length;\n    for (var i = 0; i < inputLength; i++) {\n      inputs.push(parseAbiParameter(inputParams[i], {\n        modifiers: functionModifiers,\n        structs: structs,\n        type: \"function\"\n      }));\n    }\n    var outputs = [];\n    if (match.returns) {\n      var outputParams = splitParameters(match.returns);\n      var outputLength = outputParams.length;\n      for (var _i = 0; _i < outputLength; _i++) {\n        outputs.push(parseAbiParameter(outputParams[_i], {\n          modifiers: functionModifiers,\n          structs: structs,\n          type: \"function\"\n        }));\n      }\n    }\n    return {\n      name: match.name,\n      type: \"function\",\n      stateMutability: (_match$stateMutabilit = match.stateMutability) !== null && _match$stateMutabilit !== void 0 ? _match$stateMutabilit : \"nonpayable\",\n      inputs: inputs,\n      outputs: outputs\n    };\n  }\n  if (isEventSignature(signature)) {\n    var _match = execEventSignature(signature);\n    if (!_match) throw new BaseError(\"Invalid event signature.\", {\n      details: signature\n    });\n    var params = splitParameters(_match.parameters);\n    var abiParameters = [];\n    var length = params.length;\n    for (var _i2 = 0; _i2 < length; _i2++) {\n      abiParameters.push(parseAbiParameter(params[_i2], {\n        modifiers: eventModifiers,\n        structs: structs,\n        type: \"event\"\n      }));\n    }\n    return {\n      name: _match.name,\n      type: \"event\",\n      inputs: abiParameters\n    };\n  }\n  if (isErrorSignature(signature)) {\n    var _match2 = execErrorSignature(signature);\n    if (!_match2) throw new BaseError(\"Invalid error signature.\", {\n      details: signature\n    });\n    var _params = splitParameters(_match2.parameters);\n    var _abiParameters = [];\n    var _length = _params.length;\n    for (var _i3 = 0; _i3 < _length; _i3++) {\n      _abiParameters.push(parseAbiParameter(_params[_i3], {\n        structs: structs,\n        type: \"error\"\n      }));\n    }\n    return {\n      name: _match2.name,\n      type: \"error\",\n      inputs: _abiParameters\n    };\n  }\n  if (isConstructorSignature(signature)) {\n    var _match3$stateMutabili;\n    var _match3 = execConstructorSignature(signature);\n    if (!_match3) throw new BaseError(\"Invalid constructor signature.\", {\n      details: signature\n    });\n    var _params2 = splitParameters(_match3.parameters);\n    var _abiParameters2 = [];\n    var _length2 = _params2.length;\n    for (var _i4 = 0; _i4 < _length2; _i4++) {\n      _abiParameters2.push(parseAbiParameter(_params2[_i4], {\n        structs: structs,\n        type: \"constructor\"\n      }));\n    }\n    return {\n      type: \"constructor\",\n      stateMutability: (_match3$stateMutabili = _match3.stateMutability) !== null && _match3$stateMutabili !== void 0 ? _match3$stateMutabili : \"nonpayable\",\n      inputs: _abiParameters2\n    };\n  }\n  if (isFallbackSignature(signature)) return {\n    type: \"fallback\"\n  };\n  if (isReceiveSignature(signature)) return {\n    type: \"receive\",\n    stateMutability: \"payable\"\n  };\n  throw new BaseError(\"Unknown signature.\", {\n    details: signature\n  });\n}\nvar abiParameterWithoutTupleRegex = /*#__PURE__*/_wrapRegExp(/^([a-zA-Z0-9_]+?)((?:\\[\\d*?\\])+?)?(?:\\s(calldata|indexed|memory|storage{1}))?(?:\\s([a-zA-Z0-9_]+))?$/, {\n  type: 1,\n  array: 2,\n  modifier: 3,\n  name: 4\n});\nvar abiParameterWithTupleRegex = /*#__PURE__*/_wrapRegExp(/^\\((.+?)\\)((?:\\[\\d*?\\])+?)?(?:\\s(calldata|indexed|memory|storage{1}))?(?:\\s([a-zA-Z0-9_]+))?$/, {\n  type: 1,\n  array: 2,\n  modifier: 3,\n  name: 4\n});\nvar dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n  var _options$structs, _match$array;\n  var parameterCacheKey = getParameterCacheKey(param, options === null || options === void 0 ? void 0 : options.type);\n  if (parameterCache.has(parameterCacheKey)) return parameterCache.get(parameterCacheKey);\n  var isTuple = isTupleRegex.test(param);\n  var match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n  if (!match) throw new BaseError(\"Invalid ABI parameter.\", {\n    details: param\n  });\n  if (match.name && isSolidityKeyword(match.name)) throw new BaseError(\"Invalid ABI parameter.\", {\n    details: param,\n    metaMessages: [\"\\\"\".concat(match.name, \"\\\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html\")]\n  });\n  var name2 = match.name ? {\n    name: match.name\n  } : {};\n  var indexed = match.modifier === \"indexed\" ? {\n    indexed: true\n  } : {};\n  var structs = (_options$structs = options === null || options === void 0 ? void 0 : options.structs) !== null && _options$structs !== void 0 ? _options$structs : {};\n  var type;\n  var components = {};\n  if (isTuple) {\n    type = \"tuple\";\n    var params = splitParameters(match.type);\n    var components_ = [];\n    var length = params.length;\n    for (var i = 0; i < length; i++) {\n      components_.push(parseAbiParameter(params[i], {\n        structs: structs\n      }));\n    }\n    components = {\n      components: components_\n    };\n  } else if (match.type in structs) {\n    type = \"tuple\";\n    components = {\n      components: structs[match.type]\n    };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = \"\".concat(match.type, \"256\");\n  } else {\n    type = match.type;\n    if (!((options === null || options === void 0 ? void 0 : options.type) === \"struct\") && !isSolidityType(type)) throw new BaseError(\"Unknown type.\", {\n      metaMessages: [\"Type \\\"\".concat(type, \"\\\" is not a valid ABI type.\")]\n    });\n  }\n  if (match.modifier) {\n    var _options$modifiers, _options$modifiers$ha;\n    if (!(options !== null && options !== void 0 && (_options$modifiers = options.modifiers) !== null && _options$modifiers !== void 0 && (_options$modifiers$ha = _options$modifiers.has) !== null && _options$modifiers$ha !== void 0 && _options$modifiers$ha.call(_options$modifiers, match.modifier))) throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [\"Modifier \\\"\".concat(match.modifier, \"\\\" not allowed\").concat(options !== null && options !== void 0 && options.type ? \" in \\\"\".concat(options.type, \"\\\" type\") : \"\", \".\")]\n    });\n    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array)) throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [\"Modifier \\\"\".concat(match.modifier, \"\\\" not allowed\").concat(options !== null && options !== void 0 && options.type ? \" in \\\"\".concat(options.type, \"\\\" type\") : \"\", \".\"), \"Data location can only be specified for array, struct, or mapping types, but \\\"\".concat(match.modifier, \"\\\" was given.\")]\n    });\n  }\n  var abiParameter = _objectSpread(_objectSpread(_objectSpread({\n    type: \"\".concat(type).concat((_match$array = match.array) !== null && _match$array !== void 0 ? _match$array : \"\")\n  }, name2), indexed), components);\n  parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\nfunction splitParameters(params) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var current = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (params === \"\") {\n    if (current === \"\") return result;\n    if (depth !== 0) throw new BaseError(\"Unbalanced parentheses.\", {\n      metaMessages: [\"\\\"\".concat(current.trim(), \"\\\" has too many \").concat(depth > 0 ? \"opening\" : \"closing\", \" parentheses.\")],\n      details: \"Depth \\\"\".concat(depth, \"\\\"\")\n    });\n    return [].concat(_toConsumableArray(result), [current.trim()]);\n  }\n  var length = params.length;\n  for (var i = 0; i < length; i++) {\n    var char = params[i];\n    var tail = params.slice(i + 1);\n    switch (char) {\n      case \",\":\n        return depth === 0 ? splitParameters(tail, [].concat(_toConsumableArray(result), [current.trim()])) : splitParameters(tail, result, \"\".concat(current).concat(char), depth);\n      case \"(\":\n        return splitParameters(tail, result, \"\".concat(current).concat(char), depth + 1);\n      case \")\":\n        return splitParameters(tail, result, \"\".concat(current).concat(char), depth - 1);\n      default:\n        return splitParameters(tail, result, \"\".concat(current).concat(char), depth);\n    }\n  }\n  return [];\n}\nfunction isSolidityType(type) {\n  return type === \"address\" || type === \"bool\" || type === \"function\" || type === \"string\" || bytesRegex.test(type) || integerRegex.test(type);\n}\nvar protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\nfunction isSolidityKeyword(name2) {\n  return name2 === \"address\" || name2 === \"bool\" || name2 === \"function\" || name2 === \"string\" || name2 === \"tuple\" || bytesRegex.test(name2) || integerRegex.test(name2) || protectedKeywordsRegex.test(name2);\n}\nfunction isValidDataLocation(type, isArray) {\n  return isArray || type === \"bytes\" || type === \"string\" || type === \"tuple\";\n}\n\n// src/human-readable/runtime/structs.ts\nfunction parseStructs(signatures) {\n  var shallowStructs = {};\n  var signaturesLength = signatures.length;\n  for (var i = 0; i < signaturesLength; i++) {\n    var signature = signatures[i];\n    if (!isStructSignature(signature)) continue;\n    var match = execStructSignature(signature);\n    if (!match) throw new BaseError(\"Invalid struct signature.\", {\n      details: signature\n    });\n    var properties = match.properties.split(\";\");\n    var components = [];\n    var propertiesLength = properties.length;\n    for (var k = 0; k < propertiesLength; k++) {\n      var property = properties[k];\n      var trimmed = property.trim();\n      if (!trimmed) continue;\n      var abiParameter = parseAbiParameter(trimmed, {\n        type: \"struct\"\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length) throw new BaseError(\"Invalid struct signature.\", {\n      details: signature,\n      metaMessages: [\"No properties exist.\"]\n    });\n    shallowStructs[match.name] = components;\n  }\n  var resolvedStructs = {};\n  var entries = Object.entries(shallowStructs);\n  var entriesLength = entries.length;\n  for (var _i5 = 0; _i5 < entriesLength; _i5++) {\n    var _entries$_i = _slicedToArray(entries[_i5], 2),\n      name2 = _entries$_i[0],\n      parameters = _entries$_i[1];\n    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nvar typeWithoutTupleRegex = /*#__PURE__*/_wrapRegExp(/^([a-zA-Z0-9_]+?)((?:\\[\\d*?\\])+?)?$/, {\n  type: 1,\n  array: 2\n});\nfunction resolveStructs(abiParameters, structs) {\n  var ancestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : /* @__PURE__ */new Set();\n  var components = [];\n  var length = abiParameters.length;\n  for (var i = 0; i < length; i++) {\n    var abiParameter = abiParameters[i];\n    var isTuple = isTupleRegex.test(abiParameter.type);\n    if (isTuple) components.push(abiParameter);else {\n      var match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n      if (!(match !== null && match !== void 0 && match.type)) throw new BaseError(\"Invalid ABI parameter.\", {\n        details: JSON.stringify(abiParameter, null, 2),\n        metaMessages: [\"ABI parameter type is invalid.\"]\n      });\n      var array = match.array,\n        type = match.type;\n      if (type in structs) {\n        var _structs$type;\n        if (ancestors.has(type)) throw new BaseError(\"Circular reference detected.\", {\n          metaMessages: [\"Struct \\\"\".concat(type, \"\\\" is a circular reference.\")]\n        });\n        components.push(_objectSpread(_objectSpread({}, abiParameter), {}, {\n          type: \"tuple\".concat(array !== null && array !== void 0 ? array : \"\"),\n          components: resolveStructs((_structs$type = structs[type]) !== null && _structs$type !== void 0 ? _structs$type : [], structs, /* @__PURE__ */new Set([].concat(_toConsumableArray(ancestors), [type])))\n        }));\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter);else throw new BaseError(\"Unknown type.\", {\n          metaMessages: [\"Type \\\"\".concat(type, \"\\\" is not a valid ABI type. Perhaps you forgot to include a struct signature?\")]\n        });\n      }\n    }\n  }\n  return components;\n}\n\n// src/human-readable/parseAbi.ts\nfunction parseAbi(signatures) {\n  var structs = parseStructs(signatures);\n  var abi = [];\n  var length = signatures.length;\n  for (var i = 0; i < length; i++) {\n    var signature = signatures[i];\n    if (isStructSignature(signature)) continue;\n    abi.push(parseSignature(signature, structs));\n  }\n  return abi;\n}\n\n// src/human-readable/parseAbiItem.ts\nfunction parseAbiItem(signature) {\n  var abiItem;\n  if (typeof signature === \"string\") abiItem = parseSignature(signature);else {\n    var structs = parseStructs(signature);\n    var length = signature.length;\n    for (var i = 0; i < length; i++) {\n      var signature_ = signature[i];\n      if (isStructSignature(signature_)) continue;\n      abiItem = parseSignature(signature_, structs);\n      break;\n    }\n  }\n  if (!abiItem) throw new BaseError(\"Failed to parse ABI item.\", {\n    details: \"parseAbiItem(\".concat(JSON.stringify(signature, null, 2), \")\"),\n    docsPath: \"/api/human.html#parseabiitem-1\"\n  });\n  return abiItem;\n}\n\n// src/human-readable/parseAbiParameter.ts\nfunction parseAbiParameter2(param) {\n  var abiParameter;\n  if (typeof param === \"string\") abiParameter = parseAbiParameter(param, {\n    modifiers: modifiers\n  });else {\n    var structs = parseStructs(param);\n    var length = param.length;\n    for (var i = 0; i < length; i++) {\n      var signature = param[i];\n      if (isStructSignature(signature)) continue;\n      abiParameter = parseAbiParameter(signature, {\n        modifiers: modifiers,\n        structs: structs\n      });\n      break;\n    }\n  }\n  if (!abiParameter) throw new BaseError(\"Failed to parse ABI parameter.\", {\n    details: \"parseAbiParameter(\".concat(JSON.stringify(param, null, 2), \")\"),\n    docsPath: \"/api/human.html#parseabiparameter-1\"\n  });\n  return abiParameter;\n}\n\n// src/human-readable/parseAbiParameters.ts\nfunction parseAbiParameters(params) {\n  var abiParameters = [];\n  if (typeof params === \"string\") {\n    var parameters = splitParameters(params);\n    var length = parameters.length;\n    for (var i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(parameters[i], {\n        modifiers: modifiers\n      }));\n    }\n  } else {\n    var structs = parseStructs(params);\n    var _length3 = params.length;\n    for (var _i6 = 0; _i6 < _length3; _i6++) {\n      var signature = params[_i6];\n      if (isStructSignature(signature)) continue;\n      var _parameters = splitParameters(signature);\n      var length2 = _parameters.length;\n      for (var k = 0; k < length2; k++) {\n        abiParameters.push(parseAbiParameter(_parameters[k], {\n          modifiers: modifiers,\n          structs: structs\n        }));\n      }\n    }\n  }\n  if (abiParameters.length === 0) throw new BaseError(\"Failed to parse ABI parameters.\", {\n    details: \"parseAbiParameters(\".concat(JSON.stringify(params, null, 2), \")\"),\n    docsPath: \"/api/human.html#parseabiparameters-1\"\n  });\n  return abiParameters;\n}\nexport { BaseError, narrow, parseAbi, parseAbiItem, parseAbiParameter2 as parseAbiParameter, parseAbiParameters };","map":{"version":3,"names":["bytesRegex","execTyped","integerRegex","isTupleRegex","__publicField","name","version","BaseError","_Error","_inherits","_super","_createSuper","shortMessage","_args$cause","_this","args","arguments","length","undefined","_classCallCheck","details","cause","message","docsPath","concat","_toConsumableArray","metaMessages","join","call","_assertThisInitialized","_createClass","_wrapNativeSuper","Error","narrow","value","errorSignatureRegex","_wrapRegExp","parameters","isErrorSignature","signature","test","execErrorSignature","eventSignatureRegex","isEventSignature","execEventSignature","functionSignatureRegex","scope","stateMutability","returns","isFunctionSignature","execFunctionSignature","structSignatureRegex","properties","isStructSignature","execStructSignature","constructorSignatureRegex","isConstructorSignature","execConstructorSignature","fallbackSignatureRegex","isFallbackSignature","receiveSignatureRegex","isReceiveSignature","modifiers","Set","eventModifiers","functionModifiers","getParameterCacheKey","param","type","parameterCache","Map","indexed","parseSignature","structs","_match$stateMutabilit","match","inputParams","splitParameters","inputs","inputLength","i","push","parseAbiParameter","outputs","outputParams","outputLength","params","abiParameters","_match3$stateMutabili","abiParameterWithoutTupleRegex","array","modifier","abiParameterWithTupleRegex","dynamicIntegerRegex","options","_options$structs","_match$array","parameterCacheKey","has","get","isTuple","isSolidityKeyword","name2","components","components_","isSolidityType","_options$modifiers","_options$modifiers$ha","isValidDataLocation","abiParameter","_objectSpread","set","result","current","depth","trim","char","tail","slice","protectedKeywordsRegex","isArray","parseStructs","signatures","shallowStructs","signaturesLength","split","propertiesLength","k","property","trimmed","resolvedStructs","entries","Object","entriesLength","_entries$_i","_slicedToArray","resolveStructs","typeWithoutTupleRegex","ancestors","JSON","stringify","_structs$type","parseAbi","abi","parseAbiItem","abiItem","signature_","parseAbiParameter2","parseAbiParameters","length2"],"sources":["D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/abitype/dist/index.mjs"],"sourcesContent":["import {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex\n} from \"./chunk-WP7KDV47.mjs\";\nimport {\n  __publicField\n} from \"./chunk-NHABU752.mjs\";\n\n// package.json\nvar name = \"abitype\";\nvar version = \"0.7.1\";\n\n// src/errors.ts\nvar BaseError = class extends Error {\n  constructor(shortMessage, args = {}) {\n    const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;\n    const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;\n    const message = [\n      shortMessage || \"An error occurred.\",\n      \"\",\n      ...args.metaMessages ? [...args.metaMessages, \"\"] : [],\n      ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],\n      ...details ? [`Details: ${details}`] : [],\n      `Version: ${name}@${version}`\n    ].join(\"\\n\");\n    super(message);\n    __publicField(this, \"details\");\n    __publicField(this, \"docsPath\");\n    __publicField(this, \"metaMessages\");\n    __publicField(this, \"shortMessage\");\n    __publicField(this, \"name\", \"AbiTypeError\");\n    if (args.cause)\n      this.cause = args.cause;\n    this.details = details;\n    this.docsPath = docsPath;\n    this.metaMessages = args.metaMessages;\n    this.shortMessage = shortMessage;\n  }\n};\n\n// src/narrow.ts\nfunction narrow(value) {\n  return value;\n}\n\n// src/human-readable/runtime/signatures.ts\nvar errorSignatureRegex = /^error (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isErrorSignature(signature) {\n  return errorSignatureRegex.test(signature);\n}\nfunction execErrorSignature(signature) {\n  return execTyped(\n    errorSignatureRegex,\n    signature\n  );\n}\nvar eventSignatureRegex = /^event (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isEventSignature(signature) {\n  return eventSignatureRegex.test(signature);\n}\nfunction execEventSignature(signature) {\n  return execTyped(\n    eventSignatureRegex,\n    signature\n  );\n}\nvar functionSignatureRegex = /^function (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns \\((?<returns>.*?)\\))?$/;\nfunction isFunctionSignature(signature) {\n  return functionSignatureRegex.test(signature);\n}\nfunction execFunctionSignature(signature) {\n  return execTyped(functionSignatureRegex, signature);\n}\nvar structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \\{(?<properties>.*?)\\}$/;\nfunction isStructSignature(signature) {\n  return structSignatureRegex.test(signature);\n}\nfunction execStructSignature(signature) {\n  return execTyped(\n    structSignatureRegex,\n    signature\n  );\n}\nvar constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nfunction isConstructorSignature(signature) {\n  return constructorSignatureRegex.test(signature);\n}\nfunction execConstructorSignature(signature) {\n  return execTyped(constructorSignatureRegex, signature);\n}\nvar fallbackSignatureRegex = /^fallback\\(\\)$/;\nfunction isFallbackSignature(signature) {\n  return fallbackSignatureRegex.test(signature);\n}\nvar receiveSignatureRegex = /^receive\\(\\) external payable$/;\nfunction isReceiveSignature(signature) {\n  return receiveSignatureRegex.test(signature);\n}\nvar modifiers = /* @__PURE__ */ new Set([\n  \"memory\",\n  \"indexed\",\n  \"storage\",\n  \"calldata\"\n]);\nvar eventModifiers = /* @__PURE__ */ new Set([\"indexed\"]);\nvar functionModifiers = /* @__PURE__ */ new Set([\n  \"calldata\",\n  \"memory\",\n  \"storage\"\n]);\n\n// src/human-readable/runtime/cache.ts\nfunction getParameterCacheKey(param, type) {\n  if (type)\n    return `${type}:${param}`;\n  return param;\n}\nvar parameterCache = /* @__PURE__ */ new Map([\n  // Unnamed\n  [\"address\", { type: \"address\" }],\n  [\"bool\", { type: \"bool\" }],\n  [\"bytes\", { type: \"bytes\" }],\n  [\"bytes32\", { type: \"bytes32\" }],\n  [\"int\", { type: \"int256\" }],\n  [\"int256\", { type: \"int256\" }],\n  [\"string\", { type: \"string\" }],\n  [\"uint\", { type: \"uint256\" }],\n  [\"uint8\", { type: \"uint8\" }],\n  [\"uint16\", { type: \"uint16\" }],\n  [\"uint24\", { type: \"uint24\" }],\n  [\"uint32\", { type: \"uint32\" }],\n  [\"uint64\", { type: \"uint64\" }],\n  [\"uint96\", { type: \"uint96\" }],\n  [\"uint112\", { type: \"uint112\" }],\n  [\"uint160\", { type: \"uint160\" }],\n  [\"uint192\", { type: \"uint192\" }],\n  [\"uint256\", { type: \"uint256\" }],\n  // Named\n  [\"address owner\", { type: \"address\", name: \"owner\" }],\n  [\"address to\", { type: \"address\", name: \"to\" }],\n  [\"bool approved\", { type: \"bool\", name: \"approved\" }],\n  [\"bytes _data\", { type: \"bytes\", name: \"_data\" }],\n  [\"bytes data\", { type: \"bytes\", name: \"data\" }],\n  [\"bytes signature\", { type: \"bytes\", name: \"signature\" }],\n  [\"bytes32 hash\", { type: \"bytes32\", name: \"hash\" }],\n  [\"bytes32 r\", { type: \"bytes32\", name: \"r\" }],\n  [\"bytes32 root\", { type: \"bytes32\", name: \"root\" }],\n  [\"bytes32 s\", { type: \"bytes32\", name: \"s\" }],\n  [\"string name\", { type: \"string\", name: \"name\" }],\n  [\"string symbol\", { type: \"string\", name: \"symbol\" }],\n  [\"string tokenURI\", { type: \"string\", name: \"tokenURI\" }],\n  [\"uint tokenId\", { type: \"uint256\", name: \"tokenId\" }],\n  [\"uint8 v\", { type: \"uint8\", name: \"v\" }],\n  [\"uint256 balance\", { type: \"uint256\", name: \"balance\" }],\n  [\"uint256 tokenId\", { type: \"uint256\", name: \"tokenId\" }],\n  [\"uint256 value\", { type: \"uint256\", name: \"value\" }],\n  // Indexed\n  [\n    \"event:address indexed from\",\n    { type: \"address\", name: \"from\", indexed: true }\n  ],\n  [\"event:address indexed to\", { type: \"address\", name: \"to\", indexed: true }],\n  [\n    \"event:uint indexed tokenId\",\n    { type: \"uint256\", name: \"tokenId\", indexed: true }\n  ],\n  [\n    \"event:uint256 indexed tokenId\",\n    { type: \"uint256\", name: \"tokenId\", indexed: true }\n  ]\n]);\n\n// src/human-readable/runtime/utils.ts\nfunction parseSignature(signature, structs = {}) {\n  if (isFunctionSignature(signature)) {\n    const match = execFunctionSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid function signature.\", {\n        details: signature\n      });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(\n        parseAbiParameter(inputParams[i], {\n          modifiers: functionModifiers,\n          structs,\n          type: \"function\"\n        })\n      );\n    }\n    const outputs = [];\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns);\n      const outputLength = outputParams.length;\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(\n          parseAbiParameter(outputParams[i], {\n            modifiers: functionModifiers,\n            structs,\n            type: \"function\"\n          })\n        );\n      }\n    }\n    return {\n      name: match.name,\n      type: \"function\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs,\n      outputs\n    };\n  }\n  if (isEventSignature(signature)) {\n    const match = execEventSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid event signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], {\n          modifiers: eventModifiers,\n          structs,\n          type: \"event\"\n        })\n      );\n    }\n    return { name: match.name, type: \"event\", inputs: abiParameters };\n  }\n  if (isErrorSignature(signature)) {\n    const match = execErrorSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid error signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], { structs, type: \"error\" })\n      );\n    }\n    return { name: match.name, type: \"error\", inputs: abiParameters };\n  }\n  if (isConstructorSignature(signature)) {\n    const match = execConstructorSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid constructor signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], { structs, type: \"constructor\" })\n      );\n    }\n    return {\n      type: \"constructor\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs: abiParameters\n    };\n  }\n  if (isFallbackSignature(signature))\n    return { type: \"fallback\" };\n  if (isReceiveSignature(signature))\n    return {\n      type: \"receive\",\n      stateMutability: \"payable\"\n    };\n  throw new BaseError(\"Unknown signature.\", {\n    details: signature\n  });\n}\nvar abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n  const parameterCacheKey = getParameterCacheKey(param, options?.type);\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey);\n  const isTuple = isTupleRegex.test(param);\n  const match = execTyped(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param\n  );\n  if (!match)\n    throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param\n    });\n  if (match.name && isSolidityKeyword(match.name))\n    throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [\n        `\"${match.name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`\n      ]\n    });\n  const name2 = match.name ? { name: match.name } : {};\n  const indexed = match.modifier === \"indexed\" ? { indexed: true } : {};\n  const structs = options?.structs ?? {};\n  let type;\n  let components = {};\n  if (isTuple) {\n    type = \"tuple\";\n    const params = splitParameters(match.type);\n    const components_ = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      components_.push(parseAbiParameter(params[i], { structs }));\n    }\n    components = { components: components_ };\n  } else if (match.type in structs) {\n    type = \"tuple\";\n    components = { components: structs[match.type] };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`;\n  } else {\n    type = match.type;\n    if (!(options?.type === \"struct\") && !isSolidityType(type))\n      throw new BaseError(\"Unknown type.\", {\n        metaMessages: [`Type \"${type}\" is not a valid ABI type.`]\n      });\n  }\n  if (match.modifier) {\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new BaseError(\"Invalid ABI parameter.\", {\n        details: param,\n        metaMessages: [\n          `Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`\n        ]\n      });\n    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))\n      throw new BaseError(\"Invalid ABI parameter.\", {\n        details: param,\n        metaMessages: [\n          `Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`,\n          `Data location can only be specified for array, struct, or mapping types, but \"${match.modifier}\" was given.`\n        ]\n      });\n  }\n  const abiParameter = {\n    type: `${type}${match.array ?? \"\"}`,\n    ...name2,\n    ...indexed,\n    ...components\n  };\n  parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\nfunction splitParameters(params, result = [], current = \"\", depth = 0) {\n  if (params === \"\") {\n    if (current === \"\")\n      return result;\n    if (depth !== 0)\n      throw new BaseError(\"Unbalanced parentheses.\", {\n        metaMessages: [\n          `\"${current.trim()}\" has too many ${depth > 0 ? \"opening\" : \"closing\"} parentheses.`\n        ],\n        details: `Depth \"${depth}\"`\n      });\n    return [...result, current.trim()];\n  }\n  const length = params.length;\n  for (let i = 0; i < length; i++) {\n    const char = params[i];\n    const tail = params.slice(i + 1);\n    switch (char) {\n      case \",\":\n        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);\n      case \"(\":\n        return splitParameters(tail, result, `${current}${char}`, depth + 1);\n      case \")\":\n        return splitParameters(tail, result, `${current}${char}`, depth - 1);\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth);\n    }\n  }\n  return [];\n}\nfunction isSolidityType(type) {\n  return type === \"address\" || type === \"bool\" || type === \"function\" || type === \"string\" || bytesRegex.test(type) || integerRegex.test(type);\n}\nvar protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\nfunction isSolidityKeyword(name2) {\n  return name2 === \"address\" || name2 === \"bool\" || name2 === \"function\" || name2 === \"string\" || name2 === \"tuple\" || bytesRegex.test(name2) || integerRegex.test(name2) || protectedKeywordsRegex.test(name2);\n}\nfunction isValidDataLocation(type, isArray) {\n  return isArray || type === \"bytes\" || type === \"string\" || type === \"tuple\";\n}\n\n// src/human-readable/runtime/structs.ts\nfunction parseStructs(signatures) {\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!isStructSignature(signature))\n      continue;\n    const match = execStructSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid struct signature.\", {\n        details: signature\n      });\n    const properties = match.properties.split(\";\");\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed)\n        continue;\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: \"struct\"\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length)\n      throw new BaseError(\"Invalid struct signature.\", {\n        details: signature,\n        metaMessages: [\"No properties exist.\"]\n      });\n    shallowStructs[match.name] = components;\n  }\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name2, parameters] = entries[i];\n    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nvar typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = isTupleRegex.test(abiParameter.type);\n    if (isTuple)\n      components.push(abiParameter);\n    else {\n      const match = execTyped(\n        typeWithoutTupleRegex,\n        abiParameter.type\n      );\n      if (!match?.type)\n        throw new BaseError(\"Invalid ABI parameter.\", {\n          details: JSON.stringify(abiParameter, null, 2),\n          metaMessages: [\"ABI parameter type is invalid.\"]\n        });\n      const { array, type } = match;\n      if (type in structs) {\n        if (ancestors.has(type))\n          throw new BaseError(\"Circular reference detected.\", {\n            metaMessages: [`Struct \"${type}\" is a circular reference.`]\n          });\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? \"\"}`,\n          components: resolveStructs(\n            structs[type] ?? [],\n            structs,\n            /* @__PURE__ */ new Set([...ancestors, type])\n          )\n        });\n      } else {\n        if (isSolidityType(type))\n          components.push(abiParameter);\n        else\n          throw new BaseError(\"Unknown type.\", {\n            metaMessages: [\n              `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`\n            ]\n          });\n      }\n    }\n  }\n  return components;\n}\n\n// src/human-readable/parseAbi.ts\nfunction parseAbi(signatures) {\n  const structs = parseStructs(signatures);\n  const abi = [];\n  const length = signatures.length;\n  for (let i = 0; i < length; i++) {\n    const signature = signatures[i];\n    if (isStructSignature(signature))\n      continue;\n    abi.push(parseSignature(signature, structs));\n  }\n  return abi;\n}\n\n// src/human-readable/parseAbiItem.ts\nfunction parseAbiItem(signature) {\n  let abiItem;\n  if (typeof signature === \"string\")\n    abiItem = parseSignature(signature);\n  else {\n    const structs = parseStructs(signature);\n    const length = signature.length;\n    for (let i = 0; i < length; i++) {\n      const signature_ = signature[i];\n      if (isStructSignature(signature_))\n        continue;\n      abiItem = parseSignature(signature_, structs);\n      break;\n    }\n  }\n  if (!abiItem)\n    throw new BaseError(\"Failed to parse ABI item.\", {\n      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiitem-1\"\n    });\n  return abiItem;\n}\n\n// src/human-readable/parseAbiParameter.ts\nfunction parseAbiParameter2(param) {\n  let abiParameter;\n  if (typeof param === \"string\")\n    abiParameter = parseAbiParameter(param, {\n      modifiers\n    });\n  else {\n    const structs = parseStructs(param);\n    const length = param.length;\n    for (let i = 0; i < length; i++) {\n      const signature = param[i];\n      if (isStructSignature(signature))\n        continue;\n      abiParameter = parseAbiParameter(signature, { modifiers, structs });\n      break;\n    }\n  }\n  if (!abiParameter)\n    throw new BaseError(\"Failed to parse ABI parameter.\", {\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiparameter-1\"\n    });\n  return abiParameter;\n}\n\n// src/human-readable/parseAbiParameters.ts\nfunction parseAbiParameters(params) {\n  const abiParameters = [];\n  if (typeof params === \"string\") {\n    const parameters = splitParameters(params);\n    const length = parameters.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(parameters[i], { modifiers }));\n    }\n  } else {\n    const structs = parseStructs(params);\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      const signature = params[i];\n      if (isStructSignature(signature))\n        continue;\n      const parameters = splitParameters(signature);\n      const length2 = parameters.length;\n      for (let k = 0; k < length2; k++) {\n        abiParameters.push(\n          parseAbiParameter(parameters[k], { modifiers, structs })\n        );\n      }\n    }\n  }\n  if (abiParameters.length === 0)\n    throw new BaseError(\"Failed to parse ABI parameters.\", {\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiparameters-1\"\n    });\n  return abiParameters;\n}\nexport {\n  BaseError,\n  narrow,\n  parseAbi,\n  parseAbiItem,\n  parseAbiParameter2 as parseAbiParameter,\n  parseAbiParameters\n};\n"],"mappings":";;;;;;;;;;AAAA,SACEA,UAAU,EACVC,SAAS,EACTC,YAAY,EACZC,YAAY,QACP,sBAAsB;AAC7B,SACEC,aAAa,QACR,sBAAsB;;AAE7B;AACA,IAAIC,IAAI,GAAG,SAAS;AACpB,IAAIC,OAAO,GAAG,OAAO;;AAErB;AACA,IAAIC,SAAS,0BAAAC,MAAA;EAAAC,SAAA,CAAAF,SAAA,EAAAC,MAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,SAAA;EACX,SAAAA,UAAYK,YAAY,EAAa;IAAA,IAAAC,WAAA;IAAA,IAAAC,KAAA;IAAA,IAAXC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAAAG,eAAA,OAAAZ,SAAA;IACjC,IAAMa,OAAO,GAAGL,IAAI,CAACM,KAAK,YAAYd,SAAS,GAAGQ,IAAI,CAACM,KAAK,CAACD,OAAO,GAAG,CAAAP,WAAA,GAAAE,IAAI,CAACM,KAAK,cAAAR,WAAA,eAAVA,WAAA,CAAYS,OAAO,GAAGP,IAAI,CAACM,KAAK,CAACC,OAAO,GAAGP,IAAI,CAACK,OAAO;IAC9H,IAAMG,QAAQ,GAAGR,IAAI,CAACM,KAAK,YAAYd,SAAS,GAAGQ,IAAI,CAACM,KAAK,CAACE,QAAQ,IAAIR,IAAI,CAACQ,QAAQ,GAAGR,IAAI,CAACQ,QAAQ;IACvG,IAAMD,OAAO,GAAG,CACdV,YAAY,IAAI,oBAAoB,EACpC,EAAE,EAAAY,MAAA,CAAAC,kBAAA,CACCV,IAAI,CAACW,YAAY,MAAAF,MAAA,CAAAC,kBAAA,CAAOV,IAAI,CAACW,YAAY,IAAE,EAAE,KAAI,EAAE,GAAAD,kBAAA,CACnDF,QAAQ,GAAG,6BAAAC,MAAA,CAA6BD,QAAQ,EAAG,GAAG,EAAE,GAAAE,kBAAA,CACxDL,OAAO,GAAG,aAAAI,MAAA,CAAaJ,OAAO,EAAG,GAAG,EAAE,gBAAAI,MAAA,CAC7BnB,IAAI,OAAAmB,MAAA,CAAIlB,OAAO,IAC3BqB,IAAI,CAAC,IAAI,CAAC;IACZb,KAAA,GAAAJ,MAAA,CAAAkB,IAAA,OAAMN,OAAO;IACblB,aAAa,CAAAyB,sBAAA,CAAAf,KAAA,GAAO,SAAS,CAAC;IAC9BV,aAAa,CAAAyB,sBAAA,CAAAf,KAAA,GAAO,UAAU,CAAC;IAC/BV,aAAa,CAAAyB,sBAAA,CAAAf,KAAA,GAAO,cAAc,CAAC;IACnCV,aAAa,CAAAyB,sBAAA,CAAAf,KAAA,GAAO,cAAc,CAAC;IACnCV,aAAa,CAAAyB,sBAAA,CAAAf,KAAA,GAAO,MAAM,EAAE,cAAc,CAAC;IAC3C,IAAIC,IAAI,CAACM,KAAK,EACZP,KAAA,CAAKO,KAAK,GAAGN,IAAI,CAACM,KAAK;IACzBP,KAAA,CAAKM,OAAO,GAAGA,OAAO;IACtBN,KAAA,CAAKS,QAAQ,GAAGA,QAAQ;IACxBT,KAAA,CAAKY,YAAY,GAAGX,IAAI,CAACW,YAAY;IACrCZ,KAAA,CAAKF,YAAY,GAAGA,YAAY;IAAC,OAAAE,KAAA;EACnC;EAAC,OAAAgB,YAAA,CAAAvB,SAAA;AAAA,gBAAAwB,gBAAA,CAxB2BC,KAAK,EAyBlC;;AAED;AACA,SAASC,MAAMA,CAACC,KAAK,EAAE;EACrB,OAAOA,KAAK;AACd;;AAEA;AACA,IAAIC,mBAAmB,gBAAAC,WAAA,CAAG,kCAAsD;EAAA/B,IAAA;EAAAgC,UAAA;AAAA;AAChF,SAASC,gBAAgBA,CAACC,SAAS,EAAE;EACnC,OAAOJ,mBAAmB,CAACK,IAAI,CAACD,SAAS,CAAC;AAC5C;AACA,SAASE,kBAAkBA,CAACF,SAAS,EAAE;EACrC,OAAOtC,SAAS,CACdkC,mBAAmB,EACnBI,SACF,CAAC;AACH;AACA,IAAIG,mBAAmB,gBAAAN,WAAA,CAAG,kCAAsD;EAAA/B,IAAA;EAAAgC,UAAA;AAAA;AAChF,SAASM,gBAAgBA,CAACJ,SAAS,EAAE;EACnC,OAAOG,mBAAmB,CAACF,IAAI,CAACD,SAAS,CAAC;AAC5C;AACA,SAASK,kBAAkBA,CAACL,SAAS,EAAE;EACrC,OAAOtC,SAAS,CACdyC,mBAAmB,EACnBH,SACF,CAAC;AACH;AACA,IAAIM,sBAAsB,gBAAAT,WAAA,CAAG,6HAAqL;EAAA/B,IAAA;EAAAgC,UAAA;EAAAS,KAAA;EAAAC,eAAA;EAAAC,OAAA;AAAA;AAClN,SAASC,mBAAmBA,CAACV,SAAS,EAAE;EACtC,OAAOM,sBAAsB,CAACL,IAAI,CAACD,SAAS,CAAC;AAC/C;AACA,SAASW,qBAAqBA,CAACX,SAAS,EAAE;EACxC,OAAOtC,SAAS,CAAC4C,sBAAsB,EAAEN,SAAS,CAAC;AACrD;AACA,IAAIY,oBAAoB,gBAAAf,WAAA,CAAG,oCAAwD;EAAA/B,IAAA;EAAA+C,UAAA;AAAA;AACnF,SAASC,iBAAiBA,CAACd,SAAS,EAAE;EACpC,OAAOY,oBAAoB,CAACX,IAAI,CAACD,SAAS,CAAC;AAC7C;AACA,SAASe,mBAAmBA,CAACf,SAAS,EAAE;EACtC,OAAOtC,SAAS,CACdkD,oBAAoB,EACpBZ,SACF,CAAC;AACH;AACA,IAAIgB,yBAAyB,gBAAAnB,WAAA,CAAG,2CAA0E;EAAAC,UAAA;EAAAU,eAAA;AAAA;AAC1G,SAASS,sBAAsBA,CAACjB,SAAS,EAAE;EACzC,OAAOgB,yBAAyB,CAACf,IAAI,CAACD,SAAS,CAAC;AAClD;AACA,SAASkB,wBAAwBA,CAAClB,SAAS,EAAE;EAC3C,OAAOtC,SAAS,CAACsD,yBAAyB,EAAEhB,SAAS,CAAC;AACxD;AACA,IAAImB,sBAAsB,GAAG,gBAAgB;AAC7C,SAASC,mBAAmBA,CAACpB,SAAS,EAAE;EACtC,OAAOmB,sBAAsB,CAAClB,IAAI,CAACD,SAAS,CAAC;AAC/C;AACA,IAAIqB,qBAAqB,GAAG,gCAAgC;AAC5D,SAASC,kBAAkBA,CAACtB,SAAS,EAAE;EACrC,OAAOqB,qBAAqB,CAACpB,IAAI,CAACD,SAAS,CAAC;AAC9C;AACA,IAAIuB,SAAS,GAAG,eAAgB,IAAIC,GAAG,CAAC,CACtC,QAAQ,EACR,SAAS,EACT,SAAS,EACT,UAAU,CACX,CAAC;AACF,IAAIC,cAAc,GAAG,eAAgB,IAAID,GAAG,CAAC,CAAC,SAAS,CAAC,CAAC;AACzD,IAAIE,iBAAiB,GAAG,eAAgB,IAAIF,GAAG,CAAC,CAC9C,UAAU,EACV,QAAQ,EACR,SAAS,CACV,CAAC;;AAEF;AACA,SAASG,oBAAoBA,CAACC,KAAK,EAAEC,IAAI,EAAE;EACzC,IAAIA,IAAI,EACN,UAAA5C,MAAA,CAAU4C,IAAI,OAAA5C,MAAA,CAAI2C,KAAK;EACzB,OAAOA,KAAK;AACd;AACA,IAAIE,cAAc,GAAG,eAAgB,IAAIC,GAAG,CAAC;AAC3C;AACA,CAAC,SAAS,EAAE;EAAEF,IAAI,EAAE;AAAU,CAAC,CAAC,EAChC,CAAC,MAAM,EAAE;EAAEA,IAAI,EAAE;AAAO,CAAC,CAAC,EAC1B,CAAC,OAAO,EAAE;EAAEA,IAAI,EAAE;AAAQ,CAAC,CAAC,EAC5B,CAAC,SAAS,EAAE;EAAEA,IAAI,EAAE;AAAU,CAAC,CAAC,EAChC,CAAC,KAAK,EAAE;EAAEA,IAAI,EAAE;AAAS,CAAC,CAAC,EAC3B,CAAC,QAAQ,EAAE;EAAEA,IAAI,EAAE;AAAS,CAAC,CAAC,EAC9B,CAAC,QAAQ,EAAE;EAAEA,IAAI,EAAE;AAAS,CAAC,CAAC,EAC9B,CAAC,MAAM,EAAE;EAAEA,IAAI,EAAE;AAAU,CAAC,CAAC,EAC7B,CAAC,OAAO,EAAE;EAAEA,IAAI,EAAE;AAAQ,CAAC,CAAC,EAC5B,CAAC,QAAQ,EAAE;EAAEA,IAAI,EAAE;AAAS,CAAC,CAAC,EAC9B,CAAC,QAAQ,EAAE;EAAEA,IAAI,EAAE;AAAS,CAAC,CAAC,EAC9B,CAAC,QAAQ,EAAE;EAAEA,IAAI,EAAE;AAAS,CAAC,CAAC,EAC9B,CAAC,QAAQ,EAAE;EAAEA,IAAI,EAAE;AAAS,CAAC,CAAC,EAC9B,CAAC,QAAQ,EAAE;EAAEA,IAAI,EAAE;AAAS,CAAC,CAAC,EAC9B,CAAC,SAAS,EAAE;EAAEA,IAAI,EAAE;AAAU,CAAC,CAAC,EAChC,CAAC,SAAS,EAAE;EAAEA,IAAI,EAAE;AAAU,CAAC,CAAC,EAChC,CAAC,SAAS,EAAE;EAAEA,IAAI,EAAE;AAAU,CAAC,CAAC,EAChC,CAAC,SAAS,EAAE;EAAEA,IAAI,EAAE;AAAU,CAAC,CAAC;AAChC;AACA,CAAC,eAAe,EAAE;EAAEA,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE;AAAQ,CAAC,CAAC,EACrD,CAAC,YAAY,EAAE;EAAE+D,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE;AAAK,CAAC,CAAC,EAC/C,CAAC,eAAe,EAAE;EAAE+D,IAAI,EAAE,MAAM;EAAE/D,IAAI,EAAE;AAAW,CAAC,CAAC,EACrD,CAAC,aAAa,EAAE;EAAE+D,IAAI,EAAE,OAAO;EAAE/D,IAAI,EAAE;AAAQ,CAAC,CAAC,EACjD,CAAC,YAAY,EAAE;EAAE+D,IAAI,EAAE,OAAO;EAAE/D,IAAI,EAAE;AAAO,CAAC,CAAC,EAC/C,CAAC,iBAAiB,EAAE;EAAE+D,IAAI,EAAE,OAAO;EAAE/D,IAAI,EAAE;AAAY,CAAC,CAAC,EACzD,CAAC,cAAc,EAAE;EAAE+D,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE;AAAO,CAAC,CAAC,EACnD,CAAC,WAAW,EAAE;EAAE+D,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE;AAAI,CAAC,CAAC,EAC7C,CAAC,cAAc,EAAE;EAAE+D,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE;AAAO,CAAC,CAAC,EACnD,CAAC,WAAW,EAAE;EAAE+D,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE;AAAI,CAAC,CAAC,EAC7C,CAAC,aAAa,EAAE;EAAE+D,IAAI,EAAE,QAAQ;EAAE/D,IAAI,EAAE;AAAO,CAAC,CAAC,EACjD,CAAC,eAAe,EAAE;EAAE+D,IAAI,EAAE,QAAQ;EAAE/D,IAAI,EAAE;AAAS,CAAC,CAAC,EACrD,CAAC,iBAAiB,EAAE;EAAE+D,IAAI,EAAE,QAAQ;EAAE/D,IAAI,EAAE;AAAW,CAAC,CAAC,EACzD,CAAC,cAAc,EAAE;EAAE+D,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE;AAAU,CAAC,CAAC,EACtD,CAAC,SAAS,EAAE;EAAE+D,IAAI,EAAE,OAAO;EAAE/D,IAAI,EAAE;AAAI,CAAC,CAAC,EACzC,CAAC,iBAAiB,EAAE;EAAE+D,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE;AAAU,CAAC,CAAC,EACzD,CAAC,iBAAiB,EAAE;EAAE+D,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE;AAAU,CAAC,CAAC,EACzD,CAAC,eAAe,EAAE;EAAE+D,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE;AAAQ,CAAC,CAAC;AACrD;AACA,CACE,4BAA4B,EAC5B;EAAE+D,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE,MAAM;EAAEkE,OAAO,EAAE;AAAK,CAAC,CACjD,EACD,CAAC,0BAA0B,EAAE;EAAEH,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE,IAAI;EAAEkE,OAAO,EAAE;AAAK,CAAC,CAAC,EAC5E,CACE,4BAA4B,EAC5B;EAAEH,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE,SAAS;EAAEkE,OAAO,EAAE;AAAK,CAAC,CACpD,EACD,CACE,+BAA+B,EAC/B;EAAEH,IAAI,EAAE,SAAS;EAAE/D,IAAI,EAAE,SAAS;EAAEkE,OAAO,EAAE;AAAK,CAAC,CACpD,CACF,CAAC;;AAEF;AACA,SAASC,cAAcA,CAACjC,SAAS,EAAgB;EAAA,IAAdkC,OAAO,GAAAzD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAC7C,IAAIiC,mBAAmB,CAACV,SAAS,CAAC,EAAE;IAAA,IAAAmC,qBAAA;IAClC,IAAMC,KAAK,GAAGzB,qBAAqB,CAACX,SAAS,CAAC;IAC9C,IAAI,CAACoC,KAAK,EACR,MAAM,IAAIpE,SAAS,CAAC,6BAA6B,EAAE;MACjDa,OAAO,EAAEmB;IACX,CAAC,CAAC;IACJ,IAAMqC,WAAW,GAAGC,eAAe,CAACF,KAAK,CAACtC,UAAU,CAAC;IACrD,IAAMyC,MAAM,GAAG,EAAE;IACjB,IAAMC,WAAW,GAAGH,WAAW,CAAC3D,MAAM;IACtC,KAAK,IAAI+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,WAAW,EAAEC,CAAC,EAAE,EAAE;MACpCF,MAAM,CAACG,IAAI,CACTC,iBAAiB,CAACN,WAAW,CAACI,CAAC,CAAC,EAAE;QAChClB,SAAS,EAAEG,iBAAiB;QAC5BQ,OAAO,EAAPA,OAAO;QACPL,IAAI,EAAE;MACR,CAAC,CACH,CAAC;IACH;IACA,IAAMe,OAAO,GAAG,EAAE;IAClB,IAAIR,KAAK,CAAC3B,OAAO,EAAE;MACjB,IAAMoC,YAAY,GAAGP,eAAe,CAACF,KAAK,CAAC3B,OAAO,CAAC;MACnD,IAAMqC,YAAY,GAAGD,YAAY,CAACnE,MAAM;MACxC,KAAK,IAAI+D,EAAC,GAAG,CAAC,EAAEA,EAAC,GAAGK,YAAY,EAAEL,EAAC,EAAE,EAAE;QACrCG,OAAO,CAACF,IAAI,CACVC,iBAAiB,CAACE,YAAY,CAACJ,EAAC,CAAC,EAAE;UACjClB,SAAS,EAAEG,iBAAiB;UAC5BQ,OAAO,EAAPA,OAAO;UACPL,IAAI,EAAE;QACR,CAAC,CACH,CAAC;MACH;IACF;IACA,OAAO;MACL/D,IAAI,EAAEsE,KAAK,CAACtE,IAAI;MAChB+D,IAAI,EAAE,UAAU;MAChBrB,eAAe,GAAA2B,qBAAA,GAAEC,KAAK,CAAC5B,eAAe,cAAA2B,qBAAA,cAAAA,qBAAA,GAAI,YAAY;MACtDI,MAAM,EAANA,MAAM;MACNK,OAAO,EAAPA;IACF,CAAC;EACH;EACA,IAAIxC,gBAAgB,CAACJ,SAAS,CAAC,EAAE;IAC/B,IAAMoC,MAAK,GAAG/B,kBAAkB,CAACL,SAAS,CAAC;IAC3C,IAAI,CAACoC,MAAK,EACR,MAAM,IAAIpE,SAAS,CAAC,0BAA0B,EAAE;MAC9Ca,OAAO,EAAEmB;IACX,CAAC,CAAC;IACJ,IAAM+C,MAAM,GAAGT,eAAe,CAACF,MAAK,CAACtC,UAAU,CAAC;IAChD,IAAMkD,aAAa,GAAG,EAAE;IACxB,IAAMtE,MAAM,GAAGqE,MAAM,CAACrE,MAAM;IAC5B,KAAK,IAAI+D,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAG/D,MAAM,EAAE+D,GAAC,EAAE,EAAE;MAC/BO,aAAa,CAACN,IAAI,CAChBC,iBAAiB,CAACI,MAAM,CAACN,GAAC,CAAC,EAAE;QAC3BlB,SAAS,EAAEE,cAAc;QACzBS,OAAO,EAAPA,OAAO;QACPL,IAAI,EAAE;MACR,CAAC,CACH,CAAC;IACH;IACA,OAAO;MAAE/D,IAAI,EAAEsE,MAAK,CAACtE,IAAI;MAAE+D,IAAI,EAAE,OAAO;MAAEU,MAAM,EAAES;IAAc,CAAC;EACnE;EACA,IAAIjD,gBAAgB,CAACC,SAAS,CAAC,EAAE;IAC/B,IAAMoC,OAAK,GAAGlC,kBAAkB,CAACF,SAAS,CAAC;IAC3C,IAAI,CAACoC,OAAK,EACR,MAAM,IAAIpE,SAAS,CAAC,0BAA0B,EAAE;MAC9Ca,OAAO,EAAEmB;IACX,CAAC,CAAC;IACJ,IAAM+C,OAAM,GAAGT,eAAe,CAACF,OAAK,CAACtC,UAAU,CAAC;IAChD,IAAMkD,cAAa,GAAG,EAAE;IACxB,IAAMtE,OAAM,GAAGqE,OAAM,CAACrE,MAAM;IAC5B,KAAK,IAAI+D,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAG/D,OAAM,EAAE+D,GAAC,EAAE,EAAE;MAC/BO,cAAa,CAACN,IAAI,CAChBC,iBAAiB,CAACI,OAAM,CAACN,GAAC,CAAC,EAAE;QAAEP,OAAO,EAAPA,OAAO;QAAEL,IAAI,EAAE;MAAQ,CAAC,CACzD,CAAC;IACH;IACA,OAAO;MAAE/D,IAAI,EAAEsE,OAAK,CAACtE,IAAI;MAAE+D,IAAI,EAAE,OAAO;MAAEU,MAAM,EAAES;IAAc,CAAC;EACnE;EACA,IAAI/B,sBAAsB,CAACjB,SAAS,CAAC,EAAE;IAAA,IAAAiD,qBAAA;IACrC,IAAMb,OAAK,GAAGlB,wBAAwB,CAAClB,SAAS,CAAC;IACjD,IAAI,CAACoC,OAAK,EACR,MAAM,IAAIpE,SAAS,CAAC,gCAAgC,EAAE;MACpDa,OAAO,EAAEmB;IACX,CAAC,CAAC;IACJ,IAAM+C,QAAM,GAAGT,eAAe,CAACF,OAAK,CAACtC,UAAU,CAAC;IAChD,IAAMkD,eAAa,GAAG,EAAE;IACxB,IAAMtE,QAAM,GAAGqE,QAAM,CAACrE,MAAM;IAC5B,KAAK,IAAI+D,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAG/D,QAAM,EAAE+D,GAAC,EAAE,EAAE;MAC/BO,eAAa,CAACN,IAAI,CAChBC,iBAAiB,CAACI,QAAM,CAACN,GAAC,CAAC,EAAE;QAAEP,OAAO,EAAPA,OAAO;QAAEL,IAAI,EAAE;MAAc,CAAC,CAC/D,CAAC;IACH;IACA,OAAO;MACLA,IAAI,EAAE,aAAa;MACnBrB,eAAe,GAAAyC,qBAAA,GAAEb,OAAK,CAAC5B,eAAe,cAAAyC,qBAAA,cAAAA,qBAAA,GAAI,YAAY;MACtDV,MAAM,EAAES;IACV,CAAC;EACH;EACA,IAAI5B,mBAAmB,CAACpB,SAAS,CAAC,EAChC,OAAO;IAAE6B,IAAI,EAAE;EAAW,CAAC;EAC7B,IAAIP,kBAAkB,CAACtB,SAAS,CAAC,EAC/B,OAAO;IACL6B,IAAI,EAAE,SAAS;IACfrB,eAAe,EAAE;EACnB,CAAC;EACH,MAAM,IAAIxC,SAAS,CAAC,oBAAoB,EAAE;IACxCa,OAAO,EAAEmB;EACX,CAAC,CAAC;AACJ;AACA,IAAIkD,6BAA6B,gBAAArD,WAAA,CAAG,sGAAuI;EAAAgC,IAAA;EAAAsB,KAAA;EAAAC,QAAA;EAAAtF,IAAA;AAAA;AAC3K,IAAIuF,0BAA0B,gBAAAxD,WAAA,CAAG,+FAAgI;EAAAgC,IAAA;EAAAsB,KAAA;EAAAC,QAAA;EAAAtF,IAAA;AAAA;AACjK,IAAIwF,mBAAmB,GAAG,SAAS;AACnC,SAASX,iBAAiBA,CAACf,KAAK,EAAE2B,OAAO,EAAE;EAAA,IAAAC,gBAAA,EAAAC,YAAA;EACzC,IAAMC,iBAAiB,GAAG/B,oBAAoB,CAACC,KAAK,EAAE2B,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE1B,IAAI,CAAC;EACpE,IAAIC,cAAc,CAAC6B,GAAG,CAACD,iBAAiB,CAAC,EACvC,OAAO5B,cAAc,CAAC8B,GAAG,CAACF,iBAAiB,CAAC;EAC9C,IAAMG,OAAO,GAAGjG,YAAY,CAACqC,IAAI,CAAC2B,KAAK,CAAC;EACxC,IAAMQ,KAAK,GAAG1E,SAAS,CACrBmG,OAAO,GAAGR,0BAA0B,GAAGH,6BAA6B,EACpEtB,KACF,CAAC;EACD,IAAI,CAACQ,KAAK,EACR,MAAM,IAAIpE,SAAS,CAAC,wBAAwB,EAAE;IAC5Ca,OAAO,EAAE+C;EACX,CAAC,CAAC;EACJ,IAAIQ,KAAK,CAACtE,IAAI,IAAIgG,iBAAiB,CAAC1B,KAAK,CAACtE,IAAI,CAAC,EAC7C,MAAM,IAAIE,SAAS,CAAC,wBAAwB,EAAE;IAC5Ca,OAAO,EAAE+C,KAAK;IACdzC,YAAY,EAAE,MAAAF,MAAA,CACRmD,KAAK,CAACtE,IAAI;EAElB,CAAC,CAAC;EACJ,IAAMiG,KAAK,GAAG3B,KAAK,CAACtE,IAAI,GAAG;IAAEA,IAAI,EAAEsE,KAAK,CAACtE;EAAK,CAAC,GAAG,CAAC,CAAC;EACpD,IAAMkE,OAAO,GAAGI,KAAK,CAACgB,QAAQ,KAAK,SAAS,GAAG;IAAEpB,OAAO,EAAE;EAAK,CAAC,GAAG,CAAC,CAAC;EACrE,IAAME,OAAO,IAAAsB,gBAAA,GAAGD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAErB,OAAO,cAAAsB,gBAAA,cAAAA,gBAAA,GAAI,CAAC,CAAC;EACtC,IAAI3B,IAAI;EACR,IAAImC,UAAU,GAAG,CAAC,CAAC;EACnB,IAAIH,OAAO,EAAE;IACXhC,IAAI,GAAG,OAAO;IACd,IAAMkB,MAAM,GAAGT,eAAe,CAACF,KAAK,CAACP,IAAI,CAAC;IAC1C,IAAMoC,WAAW,GAAG,EAAE;IACtB,IAAMvF,MAAM,GAAGqE,MAAM,CAACrE,MAAM;IAC5B,KAAK,IAAI+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/D,MAAM,EAAE+D,CAAC,EAAE,EAAE;MAC/BwB,WAAW,CAACvB,IAAI,CAACC,iBAAiB,CAACI,MAAM,CAACN,CAAC,CAAC,EAAE;QAAEP,OAAO,EAAPA;MAAQ,CAAC,CAAC,CAAC;IAC7D;IACA8B,UAAU,GAAG;MAAEA,UAAU,EAAEC;IAAY,CAAC;EAC1C,CAAC,MAAM,IAAI7B,KAAK,CAACP,IAAI,IAAIK,OAAO,EAAE;IAChCL,IAAI,GAAG,OAAO;IACdmC,UAAU,GAAG;MAAEA,UAAU,EAAE9B,OAAO,CAACE,KAAK,CAACP,IAAI;IAAE,CAAC;EAClD,CAAC,MAAM,IAAIyB,mBAAmB,CAACrD,IAAI,CAACmC,KAAK,CAACP,IAAI,CAAC,EAAE;IAC/CA,IAAI,MAAA5C,MAAA,CAAMmD,KAAK,CAACP,IAAI,QAAK;EAC3B,CAAC,MAAM;IACLA,IAAI,GAAGO,KAAK,CAACP,IAAI;IACjB,IAAI,EAAE,CAAA0B,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE1B,IAAI,MAAK,QAAQ,CAAC,IAAI,CAACqC,cAAc,CAACrC,IAAI,CAAC,EACxD,MAAM,IAAI7D,SAAS,CAAC,eAAe,EAAE;MACnCmB,YAAY,EAAE,WAAAF,MAAA,CAAU4C,IAAI;IAC9B,CAAC,CAAC;EACN;EACA,IAAIO,KAAK,CAACgB,QAAQ,EAAE;IAAA,IAAAe,kBAAA,EAAAC,qBAAA;IAClB,IAAI,EAACb,OAAO,aAAPA,OAAO,gBAAAY,kBAAA,GAAPZ,OAAO,CAAEhC,SAAS,cAAA4C,kBAAA,gBAAAC,qBAAA,GAAlBD,kBAAA,CAAoBR,GAAG,cAAAS,qBAAA,eAAvBA,qBAAA,CAAA/E,IAAA,CAAA8E,kBAAA,EAA0B/B,KAAK,CAACgB,QAAQ,CAAC,GAC5C,MAAM,IAAIpF,SAAS,CAAC,wBAAwB,EAAE;MAC5Ca,OAAO,EAAE+C,KAAK;MACdzC,YAAY,EAAE,eAAAF,MAAA,CACCmD,KAAK,CAACgB,QAAQ,oBAAAnE,MAAA,CAAgBsE,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAE1B,IAAI,YAAA5C,MAAA,CAAWsE,OAAO,CAAC1B,IAAI,eAAW,EAAE;IAEhG,CAAC,CAAC;IACJ,IAAIH,iBAAiB,CAACiC,GAAG,CAACvB,KAAK,CAACgB,QAAQ,CAAC,IAAI,CAACiB,mBAAmB,CAACxC,IAAI,EAAE,CAAC,CAACO,KAAK,CAACe,KAAK,CAAC,EACpF,MAAM,IAAInF,SAAS,CAAC,wBAAwB,EAAE;MAC5Ca,OAAO,EAAE+C,KAAK;MACdzC,YAAY,EAAE,eAAAF,MAAA,CACCmD,KAAK,CAACgB,QAAQ,oBAAAnE,MAAA,CAAgBsE,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAE1B,IAAI,YAAA5C,MAAA,CAAWsE,OAAO,CAAC1B,IAAI,eAAW,EAAE,0FAAA5C,MAAA,CACXmD,KAAK,CAACgB,QAAQ;IAEnG,CAAC,CAAC;EACN;EACA,IAAMkB,YAAY,GAAAC,aAAA,CAAAA,aAAA,CAAAA,aAAA;IAChB1C,IAAI,KAAA5C,MAAA,CAAK4C,IAAI,EAAA5C,MAAA,EAAAwE,YAAA,GAAGrB,KAAK,CAACe,KAAK,cAAAM,YAAA,cAAAA,YAAA,GAAI,EAAE;EAAE,GAChCM,KAAK,GACL/B,OAAO,GACPgC,UAAU,CACd;EACDlC,cAAc,CAAC0C,GAAG,CAACd,iBAAiB,EAAEY,YAAY,CAAC;EACnD,OAAOA,YAAY;AACrB;AACA,SAAShC,eAAeA,CAACS,MAAM,EAAwC;EAAA,IAAtC0B,MAAM,GAAAhG,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EAAA,IAAEiG,OAAO,GAAAjG,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EAAA,IAAEkG,KAAK,GAAAlG,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EACnE,IAAIsE,MAAM,KAAK,EAAE,EAAE;IACjB,IAAI2B,OAAO,KAAK,EAAE,EAChB,OAAOD,MAAM;IACf,IAAIE,KAAK,KAAK,CAAC,EACb,MAAM,IAAI3G,SAAS,CAAC,yBAAyB,EAAE;MAC7CmB,YAAY,EAAE,MAAAF,MAAA,CACRyF,OAAO,CAACE,IAAI,CAAC,CAAC,sBAAA3F,MAAA,CAAkB0F,KAAK,GAAG,CAAC,GAAG,SAAS,GAAG,SAAS,mBACtE;MACD9F,OAAO,aAAAI,MAAA,CAAY0F,KAAK;IAC1B,CAAC,CAAC;IACJ,UAAA1F,MAAA,CAAAC,kBAAA,CAAWuF,MAAM,IAAEC,OAAO,CAACE,IAAI,CAAC,CAAC;EACnC;EACA,IAAMlG,MAAM,GAAGqE,MAAM,CAACrE,MAAM;EAC5B,KAAK,IAAI+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/D,MAAM,EAAE+D,CAAC,EAAE,EAAE;IAC/B,IAAMoC,IAAI,GAAG9B,MAAM,CAACN,CAAC,CAAC;IACtB,IAAMqC,IAAI,GAAG/B,MAAM,CAACgC,KAAK,CAACtC,CAAC,GAAG,CAAC,CAAC;IAChC,QAAQoC,IAAI;MACV,KAAK,GAAG;QACN,OAAOF,KAAK,KAAK,CAAC,GAAGrC,eAAe,CAACwC,IAAI,KAAA7F,MAAA,CAAAC,kBAAA,CAAMuF,MAAM,IAAEC,OAAO,CAACE,IAAI,CAAC,CAAC,EAAC,CAAC,GAAGtC,eAAe,CAACwC,IAAI,EAAEL,MAAM,KAAAxF,MAAA,CAAKyF,OAAO,EAAAzF,MAAA,CAAG4F,IAAI,GAAIF,KAAK,CAAC;MACrI,KAAK,GAAG;QACN,OAAOrC,eAAe,CAACwC,IAAI,EAAEL,MAAM,KAAAxF,MAAA,CAAKyF,OAAO,EAAAzF,MAAA,CAAG4F,IAAI,GAAIF,KAAK,GAAG,CAAC,CAAC;MACtE,KAAK,GAAG;QACN,OAAOrC,eAAe,CAACwC,IAAI,EAAEL,MAAM,KAAAxF,MAAA,CAAKyF,OAAO,EAAAzF,MAAA,CAAG4F,IAAI,GAAIF,KAAK,GAAG,CAAC,CAAC;MACtE;QACE,OAAOrC,eAAe,CAACwC,IAAI,EAAEL,MAAM,KAAAxF,MAAA,CAAKyF,OAAO,EAAAzF,MAAA,CAAG4F,IAAI,GAAIF,KAAK,CAAC;IACpE;EACF;EACA,OAAO,EAAE;AACX;AACA,SAAST,cAAcA,CAACrC,IAAI,EAAE;EAC5B,OAAOA,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,UAAU,IAAIA,IAAI,KAAK,QAAQ,IAAIpE,UAAU,CAACwC,IAAI,CAAC4B,IAAI,CAAC,IAAIlE,YAAY,CAACsC,IAAI,CAAC4B,IAAI,CAAC;AAC9I;AACA,IAAImD,sBAAsB,GAAG,uZAAuZ;AACpb,SAASlB,iBAAiBA,CAACC,KAAK,EAAE;EAChC,OAAOA,KAAK,KAAK,SAAS,IAAIA,KAAK,KAAK,MAAM,IAAIA,KAAK,KAAK,UAAU,IAAIA,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,OAAO,IAAItG,UAAU,CAACwC,IAAI,CAAC8D,KAAK,CAAC,IAAIpG,YAAY,CAACsC,IAAI,CAAC8D,KAAK,CAAC,IAAIiB,sBAAsB,CAAC/E,IAAI,CAAC8D,KAAK,CAAC;AAC/M;AACA,SAASM,mBAAmBA,CAACxC,IAAI,EAAEoD,OAAO,EAAE;EAC1C,OAAOA,OAAO,IAAIpD,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,OAAO;AAC7E;;AAEA;AACA,SAASqD,YAAYA,CAACC,UAAU,EAAE;EAChC,IAAMC,cAAc,GAAG,CAAC,CAAC;EACzB,IAAMC,gBAAgB,GAAGF,UAAU,CAACzG,MAAM;EAC1C,KAAK,IAAI+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4C,gBAAgB,EAAE5C,CAAC,EAAE,EAAE;IACzC,IAAMzC,SAAS,GAAGmF,UAAU,CAAC1C,CAAC,CAAC;IAC/B,IAAI,CAAC3B,iBAAiB,CAACd,SAAS,CAAC,EAC/B;IACF,IAAMoC,KAAK,GAAGrB,mBAAmB,CAACf,SAAS,CAAC;IAC5C,IAAI,CAACoC,KAAK,EACR,MAAM,IAAIpE,SAAS,CAAC,2BAA2B,EAAE;MAC/Ca,OAAO,EAAEmB;IACX,CAAC,CAAC;IACJ,IAAMa,UAAU,GAAGuB,KAAK,CAACvB,UAAU,CAACyE,KAAK,CAAC,GAAG,CAAC;IAC9C,IAAMtB,UAAU,GAAG,EAAE;IACrB,IAAMuB,gBAAgB,GAAG1E,UAAU,CAACnC,MAAM;IAC1C,KAAK,IAAI8G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,gBAAgB,EAAEC,CAAC,EAAE,EAAE;MACzC,IAAMC,QAAQ,GAAG5E,UAAU,CAAC2E,CAAC,CAAC;MAC9B,IAAME,OAAO,GAAGD,QAAQ,CAACb,IAAI,CAAC,CAAC;MAC/B,IAAI,CAACc,OAAO,EACV;MACF,IAAMpB,YAAY,GAAG3B,iBAAiB,CAAC+C,OAAO,EAAE;QAC9C7D,IAAI,EAAE;MACR,CAAC,CAAC;MACFmC,UAAU,CAACtB,IAAI,CAAC4B,YAAY,CAAC;IAC/B;IACA,IAAI,CAACN,UAAU,CAACtF,MAAM,EACpB,MAAM,IAAIV,SAAS,CAAC,2BAA2B,EAAE;MAC/Ca,OAAO,EAAEmB,SAAS;MAClBb,YAAY,EAAE,CAAC,sBAAsB;IACvC,CAAC,CAAC;IACJiG,cAAc,CAAChD,KAAK,CAACtE,IAAI,CAAC,GAAGkG,UAAU;EACzC;EACA,IAAM2B,eAAe,GAAG,CAAC,CAAC;EAC1B,IAAMC,OAAO,GAAGC,MAAM,CAACD,OAAO,CAACR,cAAc,CAAC;EAC9C,IAAMU,aAAa,GAAGF,OAAO,CAAClH,MAAM;EACpC,KAAK,IAAI+D,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAGqD,aAAa,EAAErD,GAAC,EAAE,EAAE;IACtC,IAAAsD,WAAA,GAAAC,cAAA,CAA4BJ,OAAO,CAACnD,GAAC,CAAC;MAA/BsB,KAAK,GAAAgC,WAAA;MAAEjG,UAAU,GAAAiG,WAAA;IACxBJ,eAAe,CAAC5B,KAAK,CAAC,GAAGkC,cAAc,CAACnG,UAAU,EAAEsF,cAAc,CAAC;EACrE;EACA,OAAOO,eAAe;AACxB;AACA,IAAIO,qBAAqB,gBAAArG,WAAA,CAAG,qCAAoD;EAAAgC,IAAA;EAAAsB,KAAA;AAAA;AAChF,SAAS8C,cAAcA,CAACjD,aAAa,EAAEd,OAAO,EAAyC;EAAA,IAAvCiE,SAAS,GAAA1H,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,eAAgB,IAAI+C,GAAG,CAAC,CAAC;EACnF,IAAMwC,UAAU,GAAG,EAAE;EACrB,IAAMtF,MAAM,GAAGsE,aAAa,CAACtE,MAAM;EACnC,KAAK,IAAI+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/D,MAAM,EAAE+D,CAAC,EAAE,EAAE;IAC/B,IAAM6B,YAAY,GAAGtB,aAAa,CAACP,CAAC,CAAC;IACrC,IAAMoB,OAAO,GAAGjG,YAAY,CAACqC,IAAI,CAACqE,YAAY,CAACzC,IAAI,CAAC;IACpD,IAAIgC,OAAO,EACTG,UAAU,CAACtB,IAAI,CAAC4B,YAAY,CAAC,CAAC,KAC3B;MACH,IAAMlC,KAAK,GAAG1E,SAAS,CACrBwI,qBAAqB,EACrB5B,YAAY,CAACzC,IACf,CAAC;MACD,IAAI,EAACO,KAAK,aAALA,KAAK,eAALA,KAAK,CAAEP,IAAI,GACd,MAAM,IAAI7D,SAAS,CAAC,wBAAwB,EAAE;QAC5Ca,OAAO,EAAEuH,IAAI,CAACC,SAAS,CAAC/B,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;QAC9CnF,YAAY,EAAE,CAAC,gCAAgC;MACjD,CAAC,CAAC;MACJ,IAAQgE,KAAK,GAAWf,KAAK,CAArBe,KAAK;QAAEtB,IAAI,GAAKO,KAAK,CAAdP,IAAI;MACnB,IAAIA,IAAI,IAAIK,OAAO,EAAE;QAAA,IAAAoE,aAAA;QACnB,IAAIH,SAAS,CAACxC,GAAG,CAAC9B,IAAI,CAAC,EACrB,MAAM,IAAI7D,SAAS,CAAC,8BAA8B,EAAE;UAClDmB,YAAY,EAAE,aAAAF,MAAA,CAAY4C,IAAI;QAChC,CAAC,CAAC;QACJmC,UAAU,CAACtB,IAAI,CAAA6B,aAAA,CAAAA,aAAA,KACVD,YAAY;UACfzC,IAAI,UAAA5C,MAAA,CAAUkE,KAAK,aAALA,KAAK,cAALA,KAAK,GAAI,EAAE,CAAE;UAC3Ba,UAAU,EAAEiC,cAAc,EAAAK,aAAA,GACxBpE,OAAO,CAACL,IAAI,CAAC,cAAAyE,aAAA,cAAAA,aAAA,GAAI,EAAE,EACnBpE,OAAO,EACP,eAAgB,IAAIV,GAAG,IAAAvC,MAAA,CAAAC,kBAAA,CAAKiH,SAAS,IAAEtE,IAAI,EAAC,CAC9C;QAAC,EACF,CAAC;MACJ,CAAC,MAAM;QACL,IAAIqC,cAAc,CAACrC,IAAI,CAAC,EACtBmC,UAAU,CAACtB,IAAI,CAAC4B,YAAY,CAAC,CAAC,KAE9B,MAAM,IAAItG,SAAS,CAAC,eAAe,EAAE;UACnCmB,YAAY,EAAE,WAAAF,MAAA,CACH4C,IAAI;QAEjB,CAAC,CAAC;MACN;IACF;EACF;EACA,OAAOmC,UAAU;AACnB;;AAEA;AACA,SAASuC,QAAQA,CAACpB,UAAU,EAAE;EAC5B,IAAMjD,OAAO,GAAGgD,YAAY,CAACC,UAAU,CAAC;EACxC,IAAMqB,GAAG,GAAG,EAAE;EACd,IAAM9H,MAAM,GAAGyG,UAAU,CAACzG,MAAM;EAChC,KAAK,IAAI+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/D,MAAM,EAAE+D,CAAC,EAAE,EAAE;IAC/B,IAAMzC,SAAS,GAAGmF,UAAU,CAAC1C,CAAC,CAAC;IAC/B,IAAI3B,iBAAiB,CAACd,SAAS,CAAC,EAC9B;IACFwG,GAAG,CAAC9D,IAAI,CAACT,cAAc,CAACjC,SAAS,EAAEkC,OAAO,CAAC,CAAC;EAC9C;EACA,OAAOsE,GAAG;AACZ;;AAEA;AACA,SAASC,YAAYA,CAACzG,SAAS,EAAE;EAC/B,IAAI0G,OAAO;EACX,IAAI,OAAO1G,SAAS,KAAK,QAAQ,EAC/B0G,OAAO,GAAGzE,cAAc,CAACjC,SAAS,CAAC,CAAC,KACjC;IACH,IAAMkC,OAAO,GAAGgD,YAAY,CAAClF,SAAS,CAAC;IACvC,IAAMtB,MAAM,GAAGsB,SAAS,CAACtB,MAAM;IAC/B,KAAK,IAAI+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/D,MAAM,EAAE+D,CAAC,EAAE,EAAE;MAC/B,IAAMkE,UAAU,GAAG3G,SAAS,CAACyC,CAAC,CAAC;MAC/B,IAAI3B,iBAAiB,CAAC6F,UAAU,CAAC,EAC/B;MACFD,OAAO,GAAGzE,cAAc,CAAC0E,UAAU,EAAEzE,OAAO,CAAC;MAC7C;IACF;EACF;EACA,IAAI,CAACwE,OAAO,EACV,MAAM,IAAI1I,SAAS,CAAC,2BAA2B,EAAE;IAC/Ca,OAAO,kBAAAI,MAAA,CAAkBmH,IAAI,CAACC,SAAS,CAACrG,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC,MAAG;IAC9DhB,QAAQ,EAAE;EACZ,CAAC,CAAC;EACJ,OAAO0H,OAAO;AAChB;;AAEA;AACA,SAASE,kBAAkBA,CAAChF,KAAK,EAAE;EACjC,IAAI0C,YAAY;EAChB,IAAI,OAAO1C,KAAK,KAAK,QAAQ,EAC3B0C,YAAY,GAAG3B,iBAAiB,CAACf,KAAK,EAAE;IACtCL,SAAS,EAATA;EACF,CAAC,CAAC,CAAC,KACA;IACH,IAAMW,OAAO,GAAGgD,YAAY,CAACtD,KAAK,CAAC;IACnC,IAAMlD,MAAM,GAAGkD,KAAK,CAAClD,MAAM;IAC3B,KAAK,IAAI+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/D,MAAM,EAAE+D,CAAC,EAAE,EAAE;MAC/B,IAAMzC,SAAS,GAAG4B,KAAK,CAACa,CAAC,CAAC;MAC1B,IAAI3B,iBAAiB,CAACd,SAAS,CAAC,EAC9B;MACFsE,YAAY,GAAG3B,iBAAiB,CAAC3C,SAAS,EAAE;QAAEuB,SAAS,EAATA,SAAS;QAAEW,OAAO,EAAPA;MAAQ,CAAC,CAAC;MACnE;IACF;EACF;EACA,IAAI,CAACoC,YAAY,EACf,MAAM,IAAItG,SAAS,CAAC,gCAAgC,EAAE;IACpDa,OAAO,uBAAAI,MAAA,CAAuBmH,IAAI,CAACC,SAAS,CAACzE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,MAAG;IAC/D5C,QAAQ,EAAE;EACZ,CAAC,CAAC;EACJ,OAAOsF,YAAY;AACrB;;AAEA;AACA,SAASuC,kBAAkBA,CAAC9D,MAAM,EAAE;EAClC,IAAMC,aAAa,GAAG,EAAE;EACxB,IAAI,OAAOD,MAAM,KAAK,QAAQ,EAAE;IAC9B,IAAMjD,UAAU,GAAGwC,eAAe,CAACS,MAAM,CAAC;IAC1C,IAAMrE,MAAM,GAAGoB,UAAU,CAACpB,MAAM;IAChC,KAAK,IAAI+D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/D,MAAM,EAAE+D,CAAC,EAAE,EAAE;MAC/BO,aAAa,CAACN,IAAI,CAACC,iBAAiB,CAAC7C,UAAU,CAAC2C,CAAC,CAAC,EAAE;QAAElB,SAAS,EAATA;MAAU,CAAC,CAAC,CAAC;IACrE;EACF,CAAC,MAAM;IACL,IAAMW,OAAO,GAAGgD,YAAY,CAACnC,MAAM,CAAC;IACpC,IAAMrE,QAAM,GAAGqE,MAAM,CAACrE,MAAM;IAC5B,KAAK,IAAI+D,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAG/D,QAAM,EAAE+D,GAAC,EAAE,EAAE;MAC/B,IAAMzC,SAAS,GAAG+C,MAAM,CAACN,GAAC,CAAC;MAC3B,IAAI3B,iBAAiB,CAACd,SAAS,CAAC,EAC9B;MACF,IAAMF,WAAU,GAAGwC,eAAe,CAACtC,SAAS,CAAC;MAC7C,IAAM8G,OAAO,GAAGhH,WAAU,CAACpB,MAAM;MACjC,KAAK,IAAI8G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,OAAO,EAAEtB,CAAC,EAAE,EAAE;QAChCxC,aAAa,CAACN,IAAI,CAChBC,iBAAiB,CAAC7C,WAAU,CAAC0F,CAAC,CAAC,EAAE;UAAEjE,SAAS,EAATA,SAAS;UAAEW,OAAO,EAAPA;QAAQ,CAAC,CACzD,CAAC;MACH;IACF;EACF;EACA,IAAIc,aAAa,CAACtE,MAAM,KAAK,CAAC,EAC5B,MAAM,IAAIV,SAAS,CAAC,iCAAiC,EAAE;IACrDa,OAAO,wBAAAI,MAAA,CAAwBmH,IAAI,CAACC,SAAS,CAACtD,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,MAAG;IACjE/D,QAAQ,EAAE;EACZ,CAAC,CAAC;EACJ,OAAOgE,aAAa;AACtB;AACA,SACEhF,SAAS,EACT0B,MAAM,EACN6G,QAAQ,EACRE,YAAY,EACZG,kBAAkB,IAAIjE,iBAAiB,EACvCkE,kBAAkB"},"metadata":{},"sourceType":"module","externalDependencies":[]}