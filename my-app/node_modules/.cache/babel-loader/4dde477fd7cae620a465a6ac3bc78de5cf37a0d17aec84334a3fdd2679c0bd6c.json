{"ast":null,"code":"import _classCallCheck from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _slicedToArray from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toArray from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _toConsumableArray from \"D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n// created 2023-09-12T22:05:14.211Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32\nvar COMPRESSED$1 = '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';\nvar FENCED = new Map([[8217, \"apostrophe\"], [8260, \"fraction slash\"], [12539, \"middle dot\"]]);\nvar NSM_MAX = 4;\nfunction decode_arithmetic(bytes) {\n  var pos = 0;\n  function u16() {\n    return bytes[pos++] << 8 | bytes[pos++];\n  }\n\n  // decode the frequency table\n  var symbol_count = u16();\n  var total = 1;\n  var acc = [0, 1]; // first symbol has frequency 1\n  for (var i = 1; i < symbol_count; i++) {\n    acc.push(total += u16());\n  }\n\n  // skip the sized-payload that the last 3 symbols index into\n  var skip = u16();\n  var pos_payload = pos;\n  pos += skip;\n  var read_width = 0;\n  var read_buffer = 0;\n  function read_bit() {\n    if (read_width == 0) {\n      // this will read beyond end of buffer\n      // but (undefined|0) => zero pad\n      read_buffer = read_buffer << 8 | bytes[pos++];\n      read_width = 8;\n    }\n    return read_buffer >> --read_width & 1;\n  }\n  var N = 31;\n  var FULL = Math.pow(2, N);\n  var HALF = FULL >>> 1;\n  var QRTR = HALF >> 1;\n  var MASK = FULL - 1;\n\n  // fill register\n  var register = 0;\n  for (var _i = 0; _i < N; _i++) register = register << 1 | read_bit();\n  var symbols = [];\n  var low = 0;\n  var range = FULL; // treat like a float\n  while (true) {\n    var value = Math.floor(((register - low + 1) * total - 1) / range);\n    var start = 0;\n    var end = symbol_count;\n    while (end - start > 1) {\n      // binary search\n      var mid = start + end >>> 1;\n      if (value < acc[mid]) {\n        end = mid;\n      } else {\n        start = mid;\n      }\n    }\n    if (start == 0) break; // first symbol is end mark\n    symbols.push(start);\n    var a = low + Math.floor(range * acc[start] / total);\n    var b = low + Math.floor(range * acc[start + 1] / total) - 1;\n    while (((a ^ b) & HALF) == 0) {\n      register = register << 1 & MASK | read_bit();\n      a = a << 1 & MASK;\n      b = b << 1 & MASK | 1;\n    }\n    while (a & ~b & QRTR) {\n      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n      a = a << 1 ^ HALF;\n      b = (b ^ HALF) << 1 | HALF | 1;\n    }\n    low = a;\n    range = 1 + b - a;\n  }\n  var offset = symbol_count - 4;\n  return symbols.map(function (x) {\n    // index into payload\n    switch (x - offset) {\n      case 3:\n        return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 2:\n        return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 1:\n        return offset + bytes[pos_payload++];\n      default:\n        return x - 1;\n    }\n  });\n}\n\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n  var pos = 0;\n  return function () {\n    return v[pos++];\n  };\n}\nfunction read_compressed_payload(s) {\n  return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\nfunction unsafe_atob(s) {\n  var lookup = [];\n  _toConsumableArray('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/').forEach(function (c, i) {\n    return lookup[c.charCodeAt(0)] = i;\n  });\n  var n = s.length;\n  var ret = new Uint8Array(6 * n >> 3);\n  for (var i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\n    carry = carry << 6 | lookup[s.charCodeAt(i)];\n    width += 6;\n    if (width >= 8) {\n      ret[pos++] = carry >> (width -= 8);\n    }\n  }\n  return ret;\n}\n\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n  return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n  var v = Array(n);\n  for (var i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\n  return v;\n}\n\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next) {\n  var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ret = [];\n  while (true) {\n    var x = next();\n    var n = next();\n    if (!n) break;\n    prev += x;\n    for (var i = 0; i < n; i++) {\n      ret.push(prev + i);\n    }\n    prev += n + 1;\n  }\n  return ret;\n}\nfunction read_sorted_arrays(next) {\n  return read_array_while(function () {\n    var v = read_sorted(next);\n    if (v.length) return v;\n  });\n}\n\n// returns map of x => ys\nfunction read_mapped(next) {\n  var ret = [];\n  while (true) {\n    var w = next();\n    if (w == 0) break;\n    ret.push(read_linear_table(w, next));\n  }\n  while (true) {\n    var _w = next() - 1;\n    if (_w < 0) break;\n    ret.push(read_replacement_table(_w, next));\n  }\n  return ret.flat();\n}\n\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n  var v = [];\n  while (true) {\n    var x = next(v.length);\n    if (!x) break;\n    v.push(x);\n  }\n  return v;\n}\n\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n  var m = Array(n).fill().map(function () {\n    return [];\n  });\n  for (var i = 0; i < w; i++) {\n    read_deltas(n, next).forEach(function (x, j) {\n      return m[j].push(x);\n    });\n  }\n  return m;\n}\n\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n  var dx = 1 + next();\n  var dy = next();\n  var vN = read_array_while(next);\n  var m = read_transposed(vN.length, 1 + w, next);\n  return m.flatMap(function (v, i) {\n    var _v = _toArray(v),\n      x = _v[0],\n      ys = _v.slice(1);\n    return Array(vN[i]).fill().map(function (_, j) {\n      var j_dy = j * dy;\n      return [x + j * dx, ys.map(function (y) {\n        return y + j_dy;\n      })];\n    });\n  });\n}\n\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n  var n = 1 + next();\n  var m = read_transposed(n, 1 + w, next);\n  return m.map(function (v) {\n    return [v[0], v.slice(1)];\n  });\n}\nfunction read_trie(next) {\n  var ret = [];\n  var sorted = read_sorted(next);\n  expand(decode([]), []);\n  return ret; // not sorted\n  function decode(Q) {\n    // characters that lead into this node\n    var S = next(); // state: valid, save, check\n    var B = read_array_while(function () {\n      // buckets leading to new nodes\n      var cps = read_sorted(next).map(function (i) {\n        return sorted[i];\n      });\n      if (cps.length) return decode(cps);\n    });\n    return {\n      S: S,\n      B: B,\n      Q: Q\n    };\n  }\n  function expand(_ref, cps, saved) {\n    var S = _ref.S,\n      B = _ref.B;\n    if (S & 4 && saved === cps[cps.length - 1]) return;\n    if (S & 2) saved = cps[cps.length - 1];\n    if (S & 1) ret.push(cps);\n    var _iterator = _createForOfIteratorHelper(B),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var br = _step.value;\n        var _iterator2 = _createForOfIteratorHelper(br.Q),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var cp = _step2.value;\n            expand(br, [].concat(_toConsumableArray(cps), [cp]), saved);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n}\nfunction hex_cp(cp) {\n  return cp.toString(16).toUpperCase().padStart(2, '0');\n}\nfunction quote_cp(cp) {\n  return \"{\".concat(hex_cp(cp), \"}\"); // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\nfunction explode_cp(s) {\n  // this is about 2x faster\n  var cps = [];\n  for (var pos = 0, len = s.length; pos < len;) {\n    var cp = s.codePointAt(pos);\n    pos += cp < 0x10000 ? 1 : 2;\n    cps.push(cp);\n  }\n  return cps;\n}\nfunction str_from_cps(cps) {\n  var chunk = 4096;\n  var len = cps.length;\n  if (len < chunk) return String.fromCodePoint.apply(String, _toConsumableArray(cps));\n  var buf = [];\n  for (var i = 0; i < len;) {\n    buf.push(String.fromCodePoint.apply(String, _toConsumableArray(cps.slice(i, i += chunk))));\n  }\n  return buf.join('');\n}\nfunction compare_arrays(a, b) {\n  var n = a.length;\n  var c = n - b.length;\n  for (var i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\n  return c;\n}\n\n// created 2023-09-12T22:05:14.211Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e\nvar COMPRESSED = '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';\n\n// https://unicode.org/reports/tr15/\n// for reference implementation\n// see: /derive/nf.js\n\n// algorithmic hangul\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\nvar S0 = 0xAC00;\nvar L0 = 0x1100;\nvar V0 = 0x1161;\nvar T0 = 0x11A7;\nvar L_COUNT = 19;\nvar V_COUNT = 21;\nvar T_COUNT = 28;\nvar N_COUNT = V_COUNT * T_COUNT;\nvar S_COUNT = L_COUNT * N_COUNT;\nvar S1 = S0 + S_COUNT;\nvar L1 = L0 + L_COUNT;\nvar V1 = V0 + V_COUNT;\nvar T1 = T0 + T_COUNT;\nfunction unpack_cc(packed) {\n  return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n  return packed & 0xFFFFFF;\n}\nvar SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\nfunction init$1() {\n  //console.time('nf');\n  var r = read_compressed_payload(COMPRESSED);\n  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap(function (v, i) {\n    return v.map(function (x) {\n      return [x, i + 1 << 24];\n    });\n  })); // pre-shifted\n  EXCLUSIONS = new Set(read_sorted(r));\n  DECOMP = new Map();\n  RECOMP = new Map();\n  var _iterator3 = _createForOfIteratorHelper(read_mapped(r)),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n        cp = _step3$value[0],\n        cps = _step3$value[1];\n      if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n        var _cps = _slicedToArray(cps, 2),\n          a = _cps[0],\n          b = _cps[1];\n        var bucket = RECOMP.get(a);\n        if (!bucket) {\n          bucket = new Map();\n          RECOMP.set(a, bucket);\n        }\n        bucket.set(b, cp);\n      }\n      DECOMP.set(cp, cps.reverse()); // stored reversed\n    }\n    //console.timeEnd('nf');\n    // 20230905: 11ms\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\nfunction is_hangul(cp) {\n  return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n  if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n    return a + (b - T0);\n  } else {\n    var recomp = RECOMP.get(a);\n    if (recomp) {\n      recomp = recomp.get(b);\n      if (recomp) {\n        return recomp;\n      }\n    }\n    return -1;\n  }\n}\nfunction decomposed(cps) {\n  if (!SHIFTED_RANK) init$1();\n  var ret = [];\n  var buf = [];\n  var check_order = false;\n  function add(cp) {\n    var cc = SHIFTED_RANK.get(cp);\n    if (cc) {\n      check_order = true;\n      cp |= cc;\n    }\n    ret.push(cp);\n  }\n  var _iterator4 = _createForOfIteratorHelper(cps),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var cp = _step4.value;\n      while (true) {\n        if (cp < 0x80) {\n          ret.push(cp);\n        } else if (is_hangul(cp)) {\n          var s_index = cp - S0;\n          var l_index = s_index / N_COUNT | 0;\n          var v_index = s_index % N_COUNT / T_COUNT | 0;\n          var t_index = s_index % T_COUNT;\n          add(L0 + l_index);\n          add(V0 + v_index);\n          if (t_index > 0) add(T0 + t_index);\n        } else {\n          var mapped = DECOMP.get(cp);\n          if (mapped) {\n            buf.push.apply(buf, _toConsumableArray(mapped));\n          } else {\n            add(cp);\n          }\n        }\n        if (!buf.length) break;\n        cp = buf.pop();\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  if (check_order && ret.length > 1) {\n    var prev_cc = unpack_cc(ret[0]);\n    for (var i = 1; i < ret.length; i++) {\n      var cc = unpack_cc(ret[i]);\n      if (cc == 0 || prev_cc <= cc) {\n        prev_cc = cc;\n        continue;\n      }\n      var j = i - 1;\n      while (true) {\n        var tmp = ret[j + 1];\n        ret[j + 1] = ret[j];\n        ret[j] = tmp;\n        if (!j) break;\n        prev_cc = unpack_cc(ret[--j]);\n        if (prev_cc <= cc) break;\n      }\n      prev_cc = unpack_cc(ret[i]);\n    }\n  }\n  return ret;\n}\nfunction composed_from_decomposed(v) {\n  var ret = [];\n  var stack = [];\n  var prev_cp = -1;\n  var prev_cc = 0;\n  var _iterator5 = _createForOfIteratorHelper(v),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var packed = _step5.value;\n      var cc = unpack_cc(packed);\n      var cp = unpack_cp(packed);\n      if (prev_cp == -1) {\n        if (cc == 0) {\n          prev_cp = cp;\n        } else {\n          ret.push(cp);\n        }\n      } else if (prev_cc > 0 && prev_cc >= cc) {\n        if (cc == 0) {\n          ret.push.apply(ret, [prev_cp].concat(stack));\n          stack.length = 0;\n          prev_cp = cp;\n        } else {\n          stack.push(cp);\n        }\n        prev_cc = cc;\n      } else {\n        var composed = compose_pair(prev_cp, cp);\n        if (composed >= 0) {\n          prev_cp = composed;\n        } else if (prev_cc == 0 && cc == 0) {\n          ret.push(prev_cp);\n          prev_cp = cp;\n        } else {\n          stack.push(cp);\n          prev_cc = cc;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  if (prev_cp >= 0) {\n    ret.push.apply(ret, [prev_cp].concat(stack));\n  }\n  return ret;\n}\n\n// note: cps can be iterable\nfunction nfd(cps) {\n  return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n  return composed_from_decomposed(decomposed(cps));\n}\nvar HYPHEN = 0x2D;\nvar STOP = 0x2E;\nvar STOP_CH = '.';\nvar FE0F = 0xFE0F;\nvar UNIQUE_PH = 1;\n\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\nvar Array_from = function Array_from(x) {\n  return Array.from(x);\n}; // Array.from.bind(Array);\n\nfunction group_has_cp(g, cp) {\n  // 20230913: keep primary and secondary distinct instead of creating valid union\n  return g.P.has(cp) || g.Q.has(cp);\n}\nvar Emoji = /*#__PURE__*/function (_Array) {\n  _inherits(Emoji, _Array);\n  var _super = _createSuper(Emoji);\n  function Emoji() {\n    _classCallCheck(this, Emoji);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Emoji, [{\n    key: \"is_emoji\",\n    get: function get() {\n      return true;\n    } // free tagging system\n  }]);\n  return Emoji;\n}( /*#__PURE__*/_wrapNativeSuper(Array));\nvar MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\nfunction init() {\n  if (MAPPED) return;\n  var r = read_compressed_payload(COMPRESSED$1);\n  var read_sorted_array = function read_sorted_array() {\n    return read_sorted(r);\n  };\n  var read_sorted_set = function read_sorted_set() {\n    return new Set(read_sorted_array());\n  };\n  MAPPED = new Map(read_mapped(r));\n  IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\n\n  /*\r\n  // direct include from payload is smaller than the decompression code\r\n  const FENCED = new Map(read_array_while(() => {\r\n  \tlet cp = r();\r\n  \tif (cp) return [cp, read_str(r())];\r\n  }));\r\n  */\n  // 20230217: we still need all CM for proper error formatting\n  // but norm only needs NSM subset that are potentially-valid\n  CM = read_sorted_array();\n  NSM = new Set(read_sorted_array().map(function (i) {\n    return CM[i];\n  }));\n  CM = new Set(CM);\n  ESCAPE = read_sorted_set(); // characters that should not be printed\n  NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\n\n  var chunks = read_sorted_arrays(r);\n  var unrestricted = r();\n  var read_chunked = function read_chunked() {\n    return new Set(read_sorted_array().flatMap(function (i) {\n      return chunks[i];\n    }).concat(read_sorted_array()));\n  };\n  GROUPS = read_array_while(function (i) {\n    // minifier property mangling seems unsafe\n    // so these are manually renamed to single chars\n    var N = read_array_while(r).map(function (x) {\n      return x + 0x60;\n    });\n    if (N.length) {\n      var R = i >= unrestricted; // first arent restricted\n      N[0] -= 32; // capitalize\n      N = str_from_cps(N);\n      if (R) N = \"Restricted[\".concat(N, \"]\");\n      var P = read_chunked(); // primary\n      var Q = read_chunked(); // secondary\n      var M = !r(); // not-whitelisted, check for NSM\n      // *** this code currently isn't needed ***\n      /*\r\n      let V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n      let M = r()-1; // number of combining mark\r\n      if (M < 0) { // whitelisted\r\n      \tM = new Map(read_array_while(() => {\r\n      \t\tlet i = r();\r\n      \t\tif (i) return [V[i-1], read_array_while(() => {\r\n      \t\t\tlet v = read_array_while(r);\r\n      \t\t\tif (v.length) return v.map(x => x-1);\r\n      \t\t})];\r\n      \t}));\r\n      }*/\n      return {\n        N: N,\n        P: P,\n        Q: Q,\n        M: M,\n        R: R\n      };\n    }\n  });\n\n  // decode compressed wholes\n  WHOLE_VALID = read_sorted_set();\n  WHOLE_MAP = new Map();\n  var wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort(function (a, b) {\n    return a - b;\n  }); // must be sorted\n  wholes.forEach(function (cp, i) {\n    var d = r();\n    var w = wholes[i] = d ? wholes[i - d] : {\n      V: [],\n      M: new Map()\n    };\n    w.V.push(cp); // add to member set\n    if (!WHOLE_VALID.has(cp)) {\n      WHOLE_MAP.set(cp, w); // register with whole map\n    }\n  });\n\n  // compute confusable-extent complements\n  var _iterator6 = _createForOfIteratorHelper(new Set(WHOLE_MAP.values())),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var _step6$value = _step6.value,\n        V = _step6$value.V,\n        M = _step6$value.M;\n      // connect all groups that have each whole character\n      var recs = [];\n      var _iterator10 = _createForOfIteratorHelper(V),\n        _step10;\n      try {\n        var _loop2 = function _loop2() {\n          var cp = _step10.value;\n          var gs = GROUPS.filter(function (g) {\n            return group_has_cp(g, cp);\n          });\n          var rec = recs.find(function (_ref2) {\n            var G = _ref2.G;\n            return gs.some(function (g) {\n              return G.has(g);\n            });\n          });\n          if (!rec) {\n            rec = {\n              G: new Set(),\n              V: []\n            };\n            recs.push(rec);\n          }\n          rec.V.push(cp);\n          gs.forEach(function (g) {\n            return rec.G.add(g);\n          });\n        };\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          _loop2();\n        }\n        // per character cache groups which are not a member of the extent\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      var _union = recs.flatMap(function (x) {\n        return Array_from(x.G);\n      });\n      var _loop = function _loop() {\n        var _recs$_i = _recs[_i2],\n          G = _recs$_i.G,\n          V = _recs$_i.V;\n        var complement = new Set(_union.filter(function (g) {\n          return !G.has(g);\n        }));\n        var _iterator11 = _createForOfIteratorHelper(V),\n          _step11;\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var cp = _step11.value;\n            M.set(cp, complement);\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n      };\n      for (var _i2 = 0, _recs = recs; _i2 < _recs.length; _i2++) {\n        _loop();\n      }\n    }\n\n    // compute valid set\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  var union = new Set(); // exists in 1+ groups\n  var multi = new Set(); // exists in 2+ groups\n  var add_to_union = function add_to_union(cp) {\n    return union.has(cp) ? multi.add(cp) : union.add(cp);\n  };\n  var _iterator7 = _createForOfIteratorHelper(GROUPS),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var g = _step7.value;\n      var _iterator12 = _createForOfIteratorHelper(g.P),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var cp = _step12.value;\n          add_to_union(cp);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      var _iterator13 = _createForOfIteratorHelper(g.Q),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var _cp = _step13.value;\n          add_to_union(_cp);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n    }\n    // dual purpose WHOLE_MAP: return placeholder if unique non-confusable\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  var _iterator8 = _createForOfIteratorHelper(union),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var _cp2 = _step8.value;\n      if (!WHOLE_MAP.has(_cp2) && !multi.has(_cp2)) {\n        WHOLE_MAP.set(_cp2, UNIQUE_PH);\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  VALID = new Set(Array_from(union).concat(Array_from(nfd(union)))); // possibly valid\n\n  // decode emoji\n  // 20230719: emoji are now fully-expanded to avoid quirk logic \n  EMOJI_LIST = read_trie(r).map(function (v) {\n    return Emoji.from(v);\n  }).sort(compare_arrays);\n  EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\n  var _iterator9 = _createForOfIteratorHelper(EMOJI_LIST),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var cps = _step9.value;\n      // 20230719: change to *slightly* stricter algorithm which disallows \n      // insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\n      // example: beautified [A B] (eg. flag emoji) \n      //  before: allow: [A FE0F B], error: [A FE0F FE0F B] \n      //   after: error: both\n      // note: this code now matches ENSNormalize.{cs,java} logic\n      var prev = [EMOJI_ROOT];\n      var _iterator14 = _createForOfIteratorHelper(cps),\n        _step14;\n      try {\n        var _loop3 = function _loop3() {\n          var cp = _step14.value;\n          var next = prev.map(function (node) {\n            var child = node.get(cp);\n            if (!child) {\n              // should this be object? \n              // (most have 1-2 items, few have many)\n              // 20230719: no, v8 default map is 4?\n              child = new Map();\n              node.set(cp, child);\n            }\n            return child;\n          });\n          if (cp === FE0F) {\n            var _prev;\n            (_prev = prev).push.apply(_prev, _toConsumableArray(next)); // less than 20 elements\n          } else {\n            prev = next;\n          }\n        };\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          _loop3();\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n      var _iterator15 = _createForOfIteratorHelper(prev),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var x = _step15.value;\n          x.V = cps;\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n}\n\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n  return (should_escape(cp) ? '' : \"\".concat(bidi_qq(safe_str_from_cps([cp])), \" \")) + quote_cp(cp);\n}\n\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n  return \"\\\"\".concat(s, \"\\\"\\u200E\"); // strong LTR\n}\n\nfunction check_label_extension(cps) {\n  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n    throw new Error(\"invalid label extension: \\\"\".concat(str_from_cps(cps.slice(0, 4)), \"\\\"\"));\n  }\n}\nfunction check_leading_underscore(cps) {\n  var UNDERSCORE = 0x5F;\n  for (var i = cps.lastIndexOf(UNDERSCORE); i > 0;) {\n    if (cps[--i] !== UNDERSCORE) {\n      throw new Error('underscore allowed only at start');\n    }\n  }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n  var cp = cps[0];\n  var prev = FENCED.get(cp);\n  if (prev) throw error_placement(\"leading \".concat(prev));\n  var n = cps.length;\n  var last = -1; // prevents trailing from throwing\n  for (var i = 1; i < n; i++) {\n    cp = cps[i];\n    var match = FENCED.get(cp);\n    if (match) {\n      // since cps[0] isn't fenced, cps[1] cannot throw\n      if (last == i) throw error_placement(\"\".concat(prev, \" + \").concat(match));\n      last = i + 1;\n      prev = match;\n    }\n  }\n  if (last == n) throw error_placement(\"trailing \".concat(prev));\n}\n\n// create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps) {\n  var quoter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : quote_cp;\n  //if (Number.isInteger(cps)) cps = [cps];\n  //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n  var buf = [];\n  if (is_combining_mark(cps[0])) buf.push('◌');\n  var prev = 0;\n  var n = cps.length;\n  for (var i = 0; i < n; i++) {\n    var cp = cps[i];\n    if (should_escape(cp)) {\n      buf.push(str_from_cps(cps.slice(prev, i)));\n      buf.push(quoter(cp));\n      prev = i + 1;\n    }\n  }\n  buf.push(str_from_cps(cps.slice(prev, n)));\n  return buf.join('');\n}\n\n// note: set(s) cannot be exposed because they can be modified\n// note: Object.freeze() doesn't work\nfunction is_combining_mark(cp) {\n  init();\n  return CM.has(cp);\n}\nfunction should_escape(cp) {\n  init();\n  return ESCAPE.has(cp);\n}\n\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n  init();\n  return EMOJI_LIST.map(function (x) {\n    return x.slice();\n  }); // emoji are exposed so copy\n}\n\nfunction ens_normalize_fragment(frag, decompose) {\n  init();\n  var nf = decompose ? nfd : nfc;\n  return frag.split(STOP_CH).map(function (label) {\n    return str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat());\n  }).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n  return flatten(split(name, nfc, filter_fe0f));\n}\nfunction ens_beautify(name) {\n  var labels = split(name, nfc, function (x) {\n    return x;\n  }); // emoji not exposed\n  var _iterator16 = _createForOfIteratorHelper(labels),\n    _step16;\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var _step16$value = _step16.value,\n        type = _step16$value.type,\n        output = _step16$value.output,\n        error = _step16$value.error;\n      if (error) break; // flatten will throw\n\n      // replace leading/trailing hyphen\n      // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n      // not exactly the same in every font, but very similar: \"-\" vs \"‐\"\n      /*\r\n      const UNICODE_HYPHEN = 0x2010;\r\n      // maybe this should replace all for visual consistancy?\r\n      // `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n      //for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n      if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n      let end = output.length-1;\r\n      if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n      */\n      // 20230123: WHATWG URL uses \"CheckHyphens\" false\n      // https://url.spec.whatwg.org/#idna\n\n      // update ethereum symbol\n      // ξ => Ξ if not greek\n      if (type !== 'Greek') {\n        var prev = 0;\n        while (true) {\n          var next = output.indexOf(0x3BE, prev);\n          if (next < 0) break;\n          output[next] = 0x39E;\n          prev = next + 1;\n        }\n      }\n\n      // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n      // could be fixed with special case for: 2D (.) + 200E (LTR)\n      // https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\n      //output.splice(0, 0, 0x200E);\n    }\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n  return flatten(labels);\n}\nfunction ens_split(name, preserve_emoji) {\n  return split(name, nfc, preserve_emoji ? function (x) {\n    return x.slice();\n  } : filter_fe0f); // emoji are exposed so copy\n}\n\nfunction split(name, nf, ef) {\n  if (!name) return []; // 20230719: empty name allowance\n  init();\n  var offset = 0;\n  // https://unicode.org/reports/tr46/#Validity_Criteria\n  // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n  return name.split(STOP_CH).map(function (label) {\n    var input = explode_cp(label);\n    var info = {\n      input: input,\n      offset: offset // codepoint, not substring!\n    };\n\n    offset += input.length + 1; // + stop\n    try {\n      // 1.) \"The label must be in Unicode Normalization Form NFC\"\n      var tokens = info.tokens = tokens_from_str(input, nf, ef);\n      var token_count = tokens.length;\n      var type;\n      if (!token_count) {\n        // the label was effectively empty (could of had ignored characters)\n        //norm = [];\n        //type = 'None'; // use this instead of next match, \"ASCII\"\n        // 20230120: change to strict\n        // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n        throw new Error(\"empty label\");\n      }\n      var norm = info.output = tokens.flat();\n      check_leading_underscore(norm);\n      var emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\n      if (!emoji && norm.every(function (cp) {\n        return cp < 0x80;\n      })) {\n        // special case for ascii\n        // 20230123: matches matches WHATWG, see note 3.3\n        check_label_extension(norm); // only needed for ascii\n        // cant have fenced\n        // cant have cm\n        // cant have wholes\n        // see derive: \"Fastpath ASCII\"\n        type = 'ASCII';\n      } else {\n        var chars = tokens.flatMap(function (x) {\n          return x.is_emoji ? [] : x;\n        }); // all of the nfc tokens concat together\n        if (!chars.length) {\n          // theres no text, just emoji\n          type = 'Emoji';\n        } else {\n          // 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n          if (CM.has(norm[0])) throw error_placement('leading combining mark');\n          for (var i = 1; i < token_count; i++) {\n            // we've already checked the first token\n            var cps = tokens[i];\n            if (!cps.is_emoji && CM.has(cps[0])) {\n              // every text token has emoji neighbors, eg. EtEEEtEt...\n              // bidi_qq() not needed since emoji is LTR and cps is a CM\n              throw error_placement(\"emoji + combining mark: \\\"\".concat(str_from_cps(tokens[i - 1]), \" + \").concat(safe_str_from_cps([cps[0]]), \"\\\"\"));\n            }\n          }\n          check_fenced(norm);\n          var unique = Array_from(new Set(chars));\n          var _determine_group = determine_group(unique),\n            _determine_group2 = _slicedToArray(_determine_group, 1),\n            g = _determine_group2[0]; // take the first match\n          // see derive: \"Matching Groups have Same CM Style\"\n          // alternative: could form a hybrid type: Latin/Japanese/...\t\n          check_group(g, chars); // need text in order\n          check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n          type = g.N;\n          // 20230121: consider exposing restricted flag\n          // it's simpler to just check for 'Restricted'\n          // or even better: type.endsWith(']')\n          //if (g.R) info.restricted = true;\n        }\n      }\n\n      info.type = type;\n    } catch (err) {\n      info.error = err; // use full error object\n    }\n\n    return info;\n  });\n}\nfunction check_whole(group, unique) {\n  var maker;\n  var shared = [];\n  var _iterator17 = _createForOfIteratorHelper(unique),\n    _step17;\n  try {\n    var _loop5 = function _loop5() {\n        var cp = _step17.value;\n        var whole = WHOLE_MAP.get(cp);\n        if (whole === UNIQUE_PH) return {\n          v: void 0\n        }; // unique, non-confusable\n        if (whole) {\n          var set = whole.M.get(cp); // groups which have a character that look-like this character\n          maker = maker ? maker.filter(function (g) {\n            return set.has(g);\n          }) : Array_from(set);\n          if (!maker.length) return {\n            v: void 0\n          }; // confusable intersection is empty\n        } else {\n          shared.push(cp);\n        }\n      },\n      _ret;\n    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n      _ret = _loop5();\n      if (_ret) return _ret.v;\n    }\n  } catch (err) {\n    _iterator17.e(err);\n  } finally {\n    _iterator17.f();\n  }\n  if (maker) {\n    // we have 1+ confusable\n    // check if any of the remaining groups\n    // contain the shared characters too\n    var _iterator18 = _createForOfIteratorHelper(maker),\n      _step18;\n    try {\n      var _loop4 = function _loop4() {\n        var g = _step18.value;\n        if (shared.every(function (cp) {\n          return group_has_cp(g, cp);\n        })) {\n          throw new Error(\"whole-script confusable: \".concat(group.N, \"/\").concat(g.N));\n        }\n      };\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        _loop4();\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n  }\n}\n\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n  var groups = GROUPS;\n  var _iterator19 = _createForOfIteratorHelper(unique),\n    _step19;\n  try {\n    var _loop6 = function _loop6() {\n      var cp = _step19.value;\n      // note: we need to dodge CM that are whitelisted\n      // but that code isn't currently necessary\n      var gs = groups.filter(function (g) {\n        return group_has_cp(g, cp);\n      });\n      if (!gs.length) {\n        if (!GROUPS.some(function (g) {\n          return group_has_cp(g, cp);\n        })) {\n          // the character was composed of valid parts\n          // but it's NFC form is invalid\n          // 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\n          // note: this doesn't have to be a composition\n          // 20230720: change to full check\n          throw error_disallowed(cp); // this should be rare\n        } else {\n          // there is no group that contains all these characters\n          // throw using the highest priority group that matched\n          // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n          throw error_group_member(groups[0], cp);\n        }\n      }\n      groups = gs;\n      if (gs.length == 1) return 1; // break\n      // there is only one group left\n    };\n    for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n      if (_loop6()) break;\n    }\n    // there are at least 1 group(s) with all of these characters\n  } catch (err) {\n    _iterator19.e(err);\n  } finally {\n    _iterator19.f();\n  }\n  return groups;\n}\n\n// throw on first error\nfunction flatten(split) {\n  return split.map(function (_ref3) {\n    var input = _ref3.input,\n      error = _ref3.error,\n      output = _ref3.output;\n    if (error) {\n      // don't print label again if just a single label\n      var msg = error.message;\n      // bidi_qq() only necessary if msg is digits\n      throw new Error(split.length == 1 ? msg : \"Invalid label \".concat(bidi_qq(safe_str_from_cps(input)), \": \").concat(msg));\n    }\n    return str_from_cps(output);\n  }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n  // TODO: add cp to error?\n  return new Error(\"disallowed character: \".concat(quoted_cp(cp)));\n}\nfunction error_group_member(g, cp) {\n  var quoted = quoted_cp(cp);\n  var gg = GROUPS.find(function (g) {\n    return g.P.has(cp);\n  }); // only check primary\n  if (gg) {\n    quoted = \"\".concat(gg.N, \" \").concat(quoted);\n  }\n  return new Error(\"illegal mixture: \".concat(g.N, \" + \").concat(quoted));\n}\nfunction error_placement(where) {\n  return new Error(\"illegal placement: \".concat(where));\n}\n\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n  var _iterator20 = _createForOfIteratorHelper(cps),\n    _step20;\n  try {\n    for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n      var _cp3 = _step20.value;\n      if (!group_has_cp(g, _cp3)) {\n        // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n        // at the moment, it's unnecessary to introduce an extra error type\n        // until there exists a whitelisted multi-character\n        //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n        // there are 3 cases:\n        //   1. illegal cm for wrong group => mixture error\n        //   2. illegal cm for same group => cm error\n        //       requires set of whitelist cm per group: \n        //        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\n        //   3. wrong group => mixture error\n        throw error_group_member(g, _cp3);\n      }\n    }\n    //if (M >= 0) { // we have a known fixed cm count\n  } catch (err) {\n    _iterator20.e(err);\n  } finally {\n    _iterator20.f();\n  }\n  if (g.M) {\n    // we need to check for NSM\n    var _decomposed = nfd(cps);\n    for (var i = 1, e = _decomposed.length; i < e; i++) {\n      // see: assumption\n      // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n      /*\r\n      if (CM.has(decomposed[i])) {\r\n      \tlet j = i + 1;\r\n      \twhile (j < e && CM.has(decomposed[j])) j++;\r\n      \tif (j - i > M) {\r\n      \t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n      \t}\r\n      \ti = j;\r\n      }\r\n      */\n      // 20230217: switch to NSM counting\n      // https://www.unicode.org/reports/tr39/#Optional_Detection\n      if (NSM.has(_decomposed[i])) {\n        var j = i + 1;\n        for (var cp; j < e && NSM.has(cp = _decomposed[j]); j++) {\n          // a. Forbid sequences of the same nonspacing mark.\n          for (var k = i; k < j; k++) {\n            // O(n^2) but n < 100\n            if (_decomposed[k] == cp) {\n              throw new Error(\"duplicate non-spacing marks: \".concat(quoted_cp(cp)));\n            }\n          }\n        }\n        // parse to end so we have full nsm count\n        // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n        if (j - i > NSM_MAX) {\n          // note: this slice starts with a base char or spacing-mark cm\n          throw new Error(\"excessive non-spacing marks: \".concat(bidi_qq(safe_str_from_cps(_decomposed.slice(i - 1, j))), \" (\").concat(j - i, \"/\").concat(NSM_MAX, \")\"));\n        }\n        i = j;\n      }\n    }\n  }\n  // *** this code currently isn't needed ***\n  /*\r\n  let cm_whitelist = M instanceof Map;\r\n  for (let i = 0, e = cps.length; i < e; ) {\r\n  \tlet cp = cps[i++];\r\n  \tlet seqs = cm_whitelist && M.get(cp);\r\n  \tif (seqs) { \r\n  \t\t// list of codepoints that can follow\r\n  \t\t// if this exists, this will always be 1+\r\n  \t\tlet j = i;\r\n  \t\twhile (j < e && CM.has(cps[j])) j++;\r\n  \t\tlet cms = cps.slice(i, j);\r\n  \t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n  \t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n  \t\ti = j;\r\n  \t} else if (!V.has(cp)) {\r\n  \t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n  \t\tlet quoted = quoted_cp(cp);\r\n  \t\tfor (let cp of cps) {\r\n  \t\t\tlet u = UNIQUE.get(cp);\r\n  \t\t\tif (u && u !== g) {\r\n  \t\t\t\t// if both scripts are restricted this error is confusing\r\n  \t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n  \t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n  \t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n  \t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n  \t}\r\n  }\r\n  if (!cm_whitelist) {\r\n  \tlet decomposed = nfd(cps);\r\n  \tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n  \t\tif (CM.has(decomposed[i])) {\r\n  \t\t\tlet j = i + 1;\r\n  \t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n  \t\t\tif (j - i > M) {\r\n  \t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n  \t\t\t}\r\n  \t\t\ti = j;\r\n  \t\t}\r\n  \t}\r\n  }\r\n  */\n}\n\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\n// 20230818: rename for 'process' name collision h/t Javarome\n// https://github.com/adraffy/ens-normalize.js/issues/23\nfunction tokens_from_str(input, nf, ef) {\n  var ret = [];\n  var chars = [];\n  input = input.slice().reverse(); // flip so we can pop\n  while (input.length) {\n    var emoji = consume_emoji_reversed(input);\n    if (emoji) {\n      if (chars.length) {\n        ret.push(nf(chars));\n        chars = [];\n      }\n      ret.push(ef(emoji));\n    } else {\n      var cp = input.pop();\n      if (VALID.has(cp)) {\n        chars.push(cp);\n      } else {\n        var cps = MAPPED.get(cp);\n        if (cps) {\n          var _chars;\n          (_chars = chars).push.apply(_chars, _toConsumableArray(cps)); // less than 10 elements\n        } else if (!IGNORED.has(cp)) {\n          // 20230912: unicode 15.1 changed the order of processing such that\n          // disallowed parts are only rejected after NFC\n          // https://unicode.org/reports/tr46/#Validity_Criteria\n          // this doesn't impact normalization as of today\n          // technically, this error can be removed as the group logic will apply similar logic\n          // however the error type might be less clear\n          throw error_disallowed(cp);\n        }\n      }\n    }\n  }\n  if (chars.length) {\n    ret.push(nf(chars));\n  }\n  return ret;\n}\nfunction filter_fe0f(cps) {\n  return cps.filter(function (cp) {\n    return cp != FE0F;\n  });\n}\n\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n  var node = EMOJI_ROOT;\n  var emoji;\n  var pos = cps.length;\n  while (pos) {\n    node = node.get(cps[--pos]);\n    if (!node) break;\n    var _node = node,\n      V = _node.V;\n    if (V) {\n      // this is a valid emoji (so far)\n      emoji = V;\n      if (eaten) eaten.push.apply(eaten, _toConsumableArray(cps.slice(pos).reverse())); // (optional) copy input, used for ens_tokenize()\n      cps.length = pos; // truncate\n    }\n  }\n\n  return emoji;\n}\n\n// ************************************************************\n// tokenizer \n\nvar TY_VALID = 'valid';\nvar TY_MAPPED = 'mapped';\nvar TY_IGNORED = 'ignored';\nvar TY_DISALLOWED = 'disallowed';\nvar TY_EMOJI = 'emoji';\nvar TY_NFC = 'nfc';\nvar TY_STOP = 'stop';\nfunction ens_tokenize(name) {\n  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref4$nf = _ref4.nf,\n    nf = _ref4$nf === void 0 ? true : _ref4$nf;\n  init();\n  var input = explode_cp(name).reverse();\n  var eaten = [];\n  var tokens = [];\n  while (input.length) {\n    var emoji = consume_emoji_reversed(input, eaten);\n    if (emoji) {\n      tokens.push({\n        type: TY_EMOJI,\n        emoji: emoji.slice(),\n        // copy emoji\n        input: eaten,\n        cps: filter_fe0f(emoji)\n      });\n      eaten = []; // reset buffer\n    } else {\n      var cp = input.pop();\n      if (cp == STOP) {\n        tokens.push({\n          type: TY_STOP,\n          cp: cp\n        });\n      } else if (VALID.has(cp)) {\n        tokens.push({\n          type: TY_VALID,\n          cps: [cp]\n        });\n      } else if (IGNORED.has(cp)) {\n        tokens.push({\n          type: TY_IGNORED,\n          cp: cp\n        });\n      } else {\n        var cps = MAPPED.get(cp);\n        if (cps) {\n          tokens.push({\n            type: TY_MAPPED,\n            cp: cp,\n            cps: cps.slice()\n          });\n        } else {\n          tokens.push({\n            type: TY_DISALLOWED,\n            cp: cp\n          });\n        }\n      }\n    }\n  }\n  if (nf) {\n    for (var i = 0, start = -1; i < tokens.length; i++) {\n      var token = tokens[i];\n      if (is_valid_or_mapped(token.type)) {\n        if (requires_check(token.cps)) {\n          // normalization might be needed\n          var end = i + 1;\n          for (var pos = end; pos < tokens.length; pos++) {\n            // find adjacent text\n            var _tokens$pos = tokens[pos],\n              type = _tokens$pos.type,\n              _cps2 = _tokens$pos.cps;\n            if (is_valid_or_mapped(type)) {\n              if (!requires_check(_cps2)) break;\n              end = pos + 1;\n            } else if (type !== TY_IGNORED) {\n              // || type !== TY_DISALLOWED) { \n              break;\n            }\n          }\n          if (start < 0) start = i;\n          var slice = tokens.slice(start, end);\n          var cps0 = slice.flatMap(function (x) {\n            return is_valid_or_mapped(x.type) ? x.cps : [];\n          }); // strip junk tokens\n          var _cps3 = nfc(cps0);\n          if (compare_arrays(_cps3, cps0)) {\n            // bundle into an nfc token\n            tokens.splice(start, end - start, {\n              type: TY_NFC,\n              input: cps0,\n              // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\n              cps: _cps3,\n              tokens0: collapse_valid_tokens(slice),\n              tokens: ens_tokenize(str_from_cps(_cps3), {\n                nf: false\n              })\n            });\n            i = start;\n          } else {\n            i = end - 1; // skip to end of slice\n          }\n\n          start = -1; // reset\n        } else {\n          start = i; // remember last\n        }\n      } else if (token.type !== TY_IGNORED) {\n        // 20221024: is this correct?\n        start = -1; // reset\n      }\n    }\n  }\n\n  return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n  return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n  return cps.some(function (cp) {\n    return NFC_CHECK.has(cp);\n  });\n}\nfunction collapse_valid_tokens(tokens) {\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].type == TY_VALID) {\n      var j = i + 1;\n      while (j < tokens.length && tokens[j].type == TY_VALID) j++;\n      tokens.splice(i, j - i, {\n        type: TY_VALID,\n        cps: tokens.slice(i, j).flatMap(function (x) {\n          return x.cps;\n        })\n      });\n    }\n  }\n  return tokens;\n}\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };","map":{"version":3,"names":["COMPRESSED$1","FENCED","Map","NSM_MAX","decode_arithmetic","bytes","pos","u16","symbol_count","total","acc","i","push","skip","pos_payload","read_width","read_buffer","read_bit","N","FULL","Math","pow","HALF","QRTR","MASK","register","symbols","low","range","value","floor","start","end","mid","a","b","offset","map","x","read_payload","v","read_compressed_payload","s","unsafe_atob","lookup","_toConsumableArray","forEach","c","charCodeAt","n","length","ret","Uint8Array","width","carry","signed","read_deltas","next","Array","read_sorted","prev","arguments","undefined","read_sorted_arrays","read_array_while","read_mapped","w","read_linear_table","read_replacement_table","flat","read_transposed","m","fill","j","dx","dy","vN","flatMap","_v","_toArray","ys","slice","_","j_dy","y","read_trie","sorted","expand","decode","Q","S","B","cps","_ref","saved","_iterator","_createForOfIteratorHelper","_step","done","br","_iterator2","_step2","cp","concat","err","e","f","hex_cp","toString","toUpperCase","padStart","quote_cp","explode_cp","len","codePointAt","str_from_cps","chunk","String","fromCodePoint","apply","buf","join","compare_arrays","COMPRESSED","S0","L0","V0","T0","L_COUNT","V_COUNT","T_COUNT","N_COUNT","S_COUNT","S1","L1","V1","T1","unpack_cc","packed","unpack_cp","SHIFTED_RANK","EXCLUSIONS","DECOMP","RECOMP","init$1","r","Set","_iterator3","_step3","_step3$value","_slicedToArray","has","_cps","bucket","get","set","reverse","is_hangul","compose_pair","recomp","decomposed","check_order","add","cc","_iterator4","_step4","s_index","l_index","v_index","t_index","mapped","pop","prev_cc","tmp","composed_from_decomposed","stack","prev_cp","_iterator5","_step5","composed","nfd","nfc","HYPHEN","STOP","STOP_CH","FE0F","UNIQUE_PH","Array_from","from","group_has_cp","g","P","Emoji","_Array","_inherits","_super","_createSuper","_classCallCheck","_createClass","key","_wrapNativeSuper","MAPPED","IGNORED","CM","NSM","ESCAPE","NFC_CHECK","GROUPS","WHOLE_VALID","WHOLE_MAP","VALID","EMOJI_LIST","EMOJI_ROOT","init","read_sorted_array","read_sorted_set","chunks","unrestricted","read_chunked","R","M","wholes","sort","d","V","_iterator6","values","_step6","_step6$value","recs","_iterator10","_step10","_loop2","gs","filter","rec","find","_ref2","G","some","union","_loop","_recs$_i","_recs","_i2","complement","_iterator11","_step11","multi","add_to_union","_iterator7","_step7","_iterator12","_step12","_iterator13","_step13","_iterator8","_step8","_iterator9","_step9","_iterator14","_step14","_loop3","node","child","_prev","_iterator15","_step15","quoted_cp","should_escape","bidi_qq","safe_str_from_cps","check_label_extension","Error","check_leading_underscore","UNDERSCORE","lastIndexOf","check_fenced","error_placement","last","match","quoter","is_combining_mark","ens_emoji","ens_normalize_fragment","frag","decompose","nf","split","label","tokens_from_str","filter_fe0f","ens_normalize","name","flatten","ens_beautify","labels","_iterator16","_step16","_step16$value","type","output","error","indexOf","ens_split","preserve_emoji","ef","input","info","tokens","token_count","norm","emoji","is_emoji","every","chars","unique","_determine_group","determine_group","_determine_group2","check_group","check_whole","group","maker","shared","_iterator17","_step17","_loop5","whole","_ret","_iterator18","_step18","_loop4","groups","_iterator19","_step19","_loop6","error_disallowed","error_group_member","_ref3","msg","message","quoted","gg","where","_iterator20","_step20","k","consume_emoji_reversed","_chars","eaten","_node","TY_VALID","TY_MAPPED","TY_IGNORED","TY_DISALLOWED","TY_EMOJI","TY_NFC","TY_STOP","ens_tokenize","_ref4","_ref4$nf","token","is_valid_or_mapped","requires_check","_tokens$pos","cps0","splice","tokens0","collapse_valid_tokens"],"sources":["D:/Prasanth/CCBC2/611 - Adoption of Cloud Computing and Blockchain/TelecomProject/Telcom_GitRepo/Tfq_GitRepo/app/node_modules/@adraffy/ens-normalize/dist/index.mjs"],"sourcesContent":["// created 2023-09-12T22:05:14.211Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32\nvar COMPRESSED$1 = 'AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI';\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\nconst NSM_MAX = 4;\n\nfunction decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\r\n\r\n\r\nfunction read_trie(next) {\r\n\tlet ret = [];\r\n\tlet sorted = read_sorted(next); \r\n\texpand(decode([]), []);\r\n\treturn ret; // not sorted\r\n\tfunction decode(Q) { // characters that lead into this node\r\n\t\tlet S = next(); // state: valid, save, check\r\n\t\tlet B = read_array_while(() => { // buckets leading to new nodes\r\n\t\t\tlet cps = read_sorted(next).map(i => sorted[i]);\r\n\t\t\tif (cps.length) return decode(cps);\r\n\t\t});\r\n\t\treturn {S, B, Q};\r\n\t}\r\n\tfunction expand({S, B}, cps, saved) {\r\n\t\tif (S & 4 && saved === cps[cps.length-1]) return;\r\n\t\tif (S & 2) saved = cps[cps.length-1];\r\n\t\tif (S & 1) ret.push(cps); \r\n\t\tfor (let br of B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\texpand(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\n\n// created 2023-09-12T22:05:14.211Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e\nvar COMPRESSED = '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';\n\n// https://unicode.org/reports/tr15/\r\n// for reference implementation\r\n// see: /derive/nf.js\r\n\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\r\n\r\nfunction init$1() {\r\n\t//console.time('nf');\r\n\tlet r = read_compressed_payload(COMPRESSED);\r\n\tSHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\n\tEXCLUSIONS = new Set(read_sorted(r));\r\n\tDECOMP = new Map();\r\n\tRECOMP = new Map();\r\n\tfor (let [cp, cps] of read_mapped(r)) {\r\n\t\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\t\tlet [a, b] = cps;\r\n\t\t\tlet bucket = RECOMP.get(a);\r\n\t\t\tif (!bucket) {\r\n\t\t\t\tbucket = new Map();\r\n\t\t\t\tRECOMP.set(a, bucket);\r\n\t\t\t}\r\n\t\t\tbucket.set(b, cp);\r\n\t\t}\r\n\t\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n\t}\r\n\t//console.timeEnd('nf');\r\n\t// 20230905: 11ms\r\n}\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tif (!SHIFTED_RANK) init$1();\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\n\nconst HYPHEN = 0x2D;\r\nconst STOP = 0x2E;\r\nconst STOP_CH = '.';\r\nconst FE0F = 0xFE0F;\r\nconst UNIQUE_PH = 1;\r\n\r\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\r\nconst Array_from = x => Array.from(x); // Array.from.bind(Array);\r\n\r\nfunction group_has_cp(g, cp) {\r\n\t// 20230913: keep primary and secondary distinct instead of creating valid union\r\n\treturn g.P.has(cp) || g.Q.has(cp);\r\n}\r\n\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; } // free tagging system\r\n}\r\n\r\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\r\n\r\nfunction init() {\r\n\tif (MAPPED) return;\r\n\t\r\n\tlet r = read_compressed_payload(COMPRESSED$1);\r\n\tconst read_sorted_array = () => read_sorted(r);\r\n\tconst read_sorted_set = () => new Set(read_sorted_array());\r\n\r\n\tMAPPED = new Map(read_mapped(r)); \r\n\tIGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\r\n\r\n\t/*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/\r\n\t// 20230217: we still need all CM for proper error formatting\r\n\t// but norm only needs NSM subset that are potentially-valid\r\n\tCM = read_sorted_array();\r\n\tNSM = new Set(read_sorted_array().map(i => CM[i]));\r\n\tCM = new Set(CM);\r\n\t\r\n\tESCAPE = read_sorted_set(); // characters that should not be printed\r\n\tNFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\r\n\r\n\tlet chunks = read_sorted_arrays(r);\r\n\tlet unrestricted = r();\r\n\tconst read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\r\n\tGROUPS = read_array_while(i => {\r\n\t\t// minifier property mangling seems unsafe\r\n\t\t// so these are manually renamed to single chars\r\n\t\tlet N = read_array_while(r).map(x => x+0x60);\r\n\t\tif (N.length) {\r\n\t\t\tlet R = i >= unrestricted; // first arent restricted\r\n\t\t\tN[0] -= 32; // capitalize\r\n\t\t\tN = str_from_cps(N);\r\n\t\t\tif (R) N=`Restricted[${N}]`;\r\n\t\t\tlet P = read_chunked(); // primary\r\n\t\t\tlet Q = read_chunked(); // secondary\r\n\t\t\tlet M = !r(); // not-whitelisted, check for NSM\r\n\t\t\t// *** this code currently isn't needed ***\r\n\t\t\t/*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/\r\n\t\t\treturn {N, P, Q, M, R};\r\n\t\t}\r\n\t});\r\n\r\n\t// decode compressed wholes\r\n\tWHOLE_VALID = read_sorted_set();\r\n\tWHOLE_MAP = new Map();\r\n\tlet wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a-b); // must be sorted\r\n\twholes.forEach((cp, i) => {\r\n\t\tlet d = r(); \r\n\t\tlet w = wholes[i] = d ? wholes[i-d] : {V: [], M: new Map()};\r\n\t\tw.V.push(cp); // add to member set\r\n\t\tif (!WHOLE_VALID.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t\t}\r\n\t});\r\n\r\n\t// compute confusable-extent complements\r\n\tfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t\t// connect all groups that have each whole character\r\n\t\tlet recs = [];\r\n\t\tfor (let cp of V) {\r\n\t\t\tlet gs = GROUPS.filter(g => group_has_cp(g, cp));\r\n\t\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\t\tif (!rec) {\r\n\t\t\t\trec = {G: new Set(), V: []};\r\n\t\t\t\trecs.push(rec);\r\n\t\t\t}\r\n\t\t\trec.V.push(cp);\r\n\t\t\tgs.forEach(g => rec.G.add(g));\r\n\t\t}\r\n\t\t// per character cache groups which are not a member of the extent\r\n\t\tlet union = recs.flatMap(x => Array_from(x.G));\r\n\t\tfor (let {G, V} of recs) {\r\n\t\t\tlet complement = new Set(union.filter(g => !G.has(g)));\r\n\t\t\tfor (let cp of V) {\r\n\t\t\t\tM.set(cp, complement);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// compute valid set\r\n\tlet union = new Set(); // exists in 1+ groups\r\n\tlet multi = new Set(); // exists in 2+ groups\r\n\tconst add_to_union = cp => union.has(cp) ? multi.add(cp) : union.add(cp);\r\n\tfor (let g of GROUPS) {\r\n\t\tfor (let cp of g.P) add_to_union(cp);\r\n\t\tfor (let cp of g.Q) add_to_union(cp);\r\n\t}\r\n\t// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\n\tfor (let cp of union) {\r\n\t\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t\t}\r\n\t}\r\n\tVALID = new Set(Array_from(union).concat(Array_from(nfd(union)))); // possibly valid\r\n\r\n\t// decode emoji\r\n\t// 20230719: emoji are now fully-expanded to avoid quirk logic \r\n\tEMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);\r\n\tEMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\r\n\tfor (let cps of EMOJI_LIST) {\r\n\t\t// 20230719: change to *slightly* stricter algorithm which disallows \r\n\t\t// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\r\n\t\t// example: beautified [A B] (eg. flag emoji) \r\n\t\t//  before: allow: [A FE0F B], error: [A FE0F FE0F B] \r\n\t\t//   after: error: both\r\n\t\t// note: this code now matches ENSNormalize.{cs,java} logic\r\n\t\tlet prev = [EMOJI_ROOT];\r\n\t\tfor (let cp of cps) {\r\n\t\t\tlet next = prev.map(node => {\r\n\t\t\t\tlet child = node.get(cp);\r\n\t\t\t\tif (!child) {\r\n\t\t\t\t\t// should this be object? \r\n\t\t\t\t\t// (most have 1-2 items, few have many)\r\n\t\t\t\t\t// 20230719: no, v8 default map is 4?\r\n\t\t\t\t\tchild = new Map();\r\n\t\t\t\t\tnode.set(cp, child);\r\n\t\t\t\t}\r\n\t\t\t\treturn child;\r\n\t\t\t});\r\n\t\t\tif (cp === FE0F) {\r\n\t\t\t\tprev.push(...next); // less than 20 elements\r\n\t\t\t} else {\r\n\t\t\t\tprev = next;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let x of prev) {\r\n\t\t\tx.V = cps;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`);\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('◌');\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\n// note: Object.freeze() doesn't work\r\nfunction is_combining_mark(cp) {\r\n\tinit();\r\n\treturn CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\tinit();\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\tinit();\r\n\treturn EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tinit();\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(split(name, nfc, filter_fe0f));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet labels = split(name, nfc, x => x); // emoji not exposed\r\n\tfor (let {type, output, error} of labels) {\r\n\t\tif (error) break; // flatten will throw\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"‐\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t// ξ => Ξ if not greek\r\n\t\tif (type !== 'Greek') { \r\n\t\t\tlet prev = 0;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet next = output.indexOf(0x3BE, prev);\r\n\t\t\t\tif (next < 0) break;\r\n\t\t\t\toutput[next] = 0x39E; \r\n\t\t\t\tprev = next + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t// https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(labels);\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\treturn split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy\r\n}\r\n\r\nfunction split(name, nf, ef) {\r\n\tif (!name) return []; // 20230719: empty name allowance\r\n\tinit();\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = tokens_from_str(input, nf, ef);\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} \r\n\t\t\tlet norm = info.output = tokens.flat();\r\n\t\t\tcheck_leading_underscore(norm);\r\n\t\t\tlet emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\r\n\t\t\tif (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\tcheck_label_extension(norm); // only needed for ascii\r\n\t\t\t\t// cant have fenced\r\n\t\t\t\t// cant have cm\r\n\t\t\t\t// cant have wholes\r\n\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\ttype = 'ASCII';\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\tlet unique = Array_from(new Set(chars));\r\n\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = [];\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : Array_from(set);\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaining groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => group_has_cp(g, cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => group_has_cp(g, cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (!GROUPS.some(g => group_has_cp(g, cp))) { \r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\t// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\r\n\t\t\t\t// note: this doesn't have to be a composition\r\n\t\t\t\t// 20230720: change to full check\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp)); // only check primary\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tfor (let cp of cps) {\r\n\t\tif (!group_has_cp(g, cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (g.M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\n// 20230818: rename for 'process' name collision h/t Javarome\r\n// https://github.com/adraffy/ens-normalize.js/issues/23\r\nfunction tokens_from_str(input, nf, ef) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(ef(emoji));\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps); // less than 10 elements\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\t// 20230912: unicode 15.1 changed the order of processing such that\r\n\t\t\t\t\t// disallowed parts are only rejected after NFC\r\n\t\t\t\t\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t\t\t\t\t// this doesn't impact normalization as of today\r\n\t\t\t\t\t// technically, this error can be removed as the group logic will apply similar logic\r\n\t\t\t\t\t// however the error type might be less clear\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet pos = cps.length;\r\n\twhile (pos) {\r\n\t\tnode = node.get(cps[--pos]);\r\n\t\tif (!node) break;\r\n\t\tlet {V} = node;\r\n\t\tif (V) { // this is a valid emoji (so far)\r\n\t\t\temoji = V;\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\treturn emoji;\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tinit();\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TY_EMOJI,\r\n\t\t\t\temoji: emoji.slice(), // copy emoji\r\n\t\t\t\tinput: eaten,\r\n\t\t\t\tcps: filter_fe0f(emoji)\r\n\t\t\t});\r\n\t\t\teaten = []; // reset buffer\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}